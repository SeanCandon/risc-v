//
// execution.vin
//
// Simulation of the DLX
// Written by Edsko de Vries, Summer 2003
//
// Copyright (C) 2003 - 2018 Edsko de Vries and jones@scss.tcd.ie
//
// This program is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation;
// either version 2 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//

const num CHECK = 0;
const num EXEC = 1;

AnimPipe mux1Src, mux3Src, mux4Src;

num zero;																		// {joj 3/11/12}
num newPC;																		// {joj 3/11/12}
//num branchMissPredict;														// {joj 4/11/12}
AnimPipe newMux1Src;

//x1 is stack pointer, initially points to top of stack
regFile[2].setValue(0x44);
stack.setSP(0x44);

//num nojal = 1;
num nojalr = 1;

num delayStackUpdate = 0;

num takeCondBranch = 0;
num condBranchStall = 0;

num startMulti = 1;
num multistage = CHECK;
num countDown;
num multiStall = 0;
num divDone = 0;

num noCycles;
num q1;
num p1, p2;
num a;
num boothCyc = 1;
num bit4mul;

//
// index for tag or -1 if none
//
num function btbIndex(num pc) {
    for (num lp1 = 0; lp1 < 2; lp1++)
        if (btbPC[lp1].value == pc)                                             // {joj 1/2/06}
            return lp1;
    return -1;
}

//
// ifExec
//
// 80 ticks per clock cycle (40 + 40)
//
function ifExec() {																// {joj 24/9/17}

	if ((stall == NO_STALL) || (stall == CTRL_STALL)) {
        fork(regPC.update());
        im.setActive(regPC.newValue);
    }

	wait(8);

    //
    // look for PC is branch target buffer
    //
    if ((bpMode == BRANCH_PREDICTION) && (btbIndex(regPC.value) != -1)) {
        btbLast = btbIndex(regPC.value);
        regPC.setNewValue(btbPPC[btbLast].value);                               // {joj 1/2/06}
        mux1Src = apBTB_MUX1;
    } else {
        regPC.setNewValue((regPC.value + 4) & 0x7F);
        mux1Src = apADD4_MUX1;
    }

    regPC1.setNewValue(regPC.value);
    regID.setNewInstruction(im.instruction[regPC.value / 4]);

    wait(8);

	fork(apPC_PC1.animate(64));
 	fork(apPC_IM.animate(24));
   	fork(apPC_ADD4.animate(24));

    if ((bpMode == BRANCH_PREDICTION) && (instrIsJump(regID.vIns))) {	// {joj 1/2/06}
		if (stall == CTRL_STALL) {												// {joj 3/11/12}
			apPC_MUX2.animate(12);												// {joj 3/11/12}
		} else {																// {joj 3/11/12}
        	apPC1_MUX2.animate(12);												// {joj 3/11/12}
		}
        apMUX2_BTB.animate(12);
    } else {
        wait(24);
    }

    //
    // Second half of the clock cycle
    //
    fork(apIM_ID.animate(40));

    if ((bpMode == BRANCH_PREDICTION) && (btbIndex(regPC.value) != -1)) {
        btbPC[btbIndex(regPC.value)].highlight(bhighlight);                    // {joj 1/2/06}
        btbPPC[btbIndex(regPC.value)].highlight(bhighlight);                   // {joj 1/2/06}
    }

    txtIM_ID.setTxt(regID.getNewInstrTxt());                                    // {joj 29/10/06}
    txtIM_ID.setOpacity(1, 16, 1, 1);                                           // {joj 29/10/06}

    mux1Src.animate(16);
    apMUX1_PC.animate(8);

}

function calcNoCycles(num op1) {

  num c = 0;

  num b1 = op1 & 0x01;
  num b2 = op1 & 0x02;
  b2 = b2 >> 1;
  num b3 = op1 & 0x04;
  b3 = b3 >> 2;
  num b4 = op1 & 0x08;
  b4 = b4 >> 4;

  if(b1 == 0){
    c++;
  }
  else{
    c += 2;
  }
  if(b2 == b1){
    c++;
  }
  else{
    c += 2;
  }
  if (b2 == b3){
    c++;
  }
  else{
    c += 2;
  }
  if(b3 == b4){
    c++;
  }
  else{
    c += 2;
  }
  if(bit4mul==0){
    num b5 = op1 & 0x10;
    num b6 = op1 & 0x20;
    b6 = b6 >> 1;
    num b7 = op1 & 0x40;
    b7 = b7 >> 2;
    num b8 = op1 & 0x80;
    b8 = b8 >> 4;

    if(b5 == b4){
      c++;
    }
    else{
      c += 2;
    }
    if(b6 == b5){
      c++;
    }
    else{
      c += 2;
    }
    if (b7 == b6){
      c++;
    }
    else{
      c += 2;
    }
    if(b8 == b7){
      c++;
    }
    else{
      c += 2;
    }
  }

  noCycles = c;

}

function booth8(){

  num b1 = p1 & 1;
  if(b1 != q1 && boothCyc!=2){
    if(b1 > q1){
      p2 = (se8(p2) - se8(a)) & 0xFF;
    }
    else{
      p2 = (se8(p2) + se8(a)) & 0xFF;
    }
    boothCyc = 2;
  }
  else{
    boothCyc = 1;
    num p21 = p2 & 0x01;
    p21 = p21 << 7;
    num p2m = p2 & 0x80;
    p1 = (p1 >> 1) & 0xFF;
    p1 = p1 | p21;
    p2 = (p2 >> 1) & 0xFF;
    p2 = p2 | p2m;
    q1 = b1;
  }
}

function booth(){

  num b1 = p1 & 1;
  if(b1 != q1 && boothCyc!=2){
    num p3 = p1 & 0x0F;
    num q = p1 & 0xF0;
    q = q >> 4;
    if(b1 > q1){
      q = (se8(q) - se8(a)) & 0xFF;
    }
    else{
      q = (se8(q) + se8(a)) & 0xFF;
    }
    q = q << 4;
    q = q & 0xF0;
    p1 = q | p3;
    boothCyc = 2;
  }
  else{
    boothCyc = 1;
    num lb = p1 & 0x80;
    p1 = (p1 >> 1) & 0xFF;
    p1 = p1 | lb;
    q1 = b1;
  }
}

function expandFrame(){

}

//
// set mux1Src, mux3Src and regPC.newValue and values for BTB if necessary
//
function calcNewPC() {

   // AnimPipe newMux1Src;
    if(instrIsBranch(regEX.vIns)) {
      if(takeCondBranch == 1){
        mux3Src = apDM1_MUX3;
        newPC = maybeR.value & 0x7F;
        newMux1Src = apMUX3_MUX1;
        //takeCondBranch = 0;
      }
      else{
        mux3Src = apADD4_MUX3;
        newPC = (regPC1.value + 4) & 0x7F;
        takeCondBranch = 0;
      }
    }
    else {

      if (isJorJAL(regID.vIns)) {

        // unconditional relative jump
        mux3Src = apDM1_MUX3;
        mux4Src = apMUX3_MUX4;
        newPC = (regPC1.value + regID.vRs2) & 0x7F;
        newMux1Src = apMUX3_MUX1;

      } else if (instrIsJumpR(regID.vIns)) {

        // (Unconditional) indirect jump
        // MUX3 (and hence mux3Src) unused
        newPC = (regFile[regID.vRs2].value) & 0x7F;
        newMux1Src = apRF_MUX1;
        mux4Src = apRF_MUX4;

      }
    }
}

function updBTB() {

	//branchMissPredict = 0;

	if (newPC != regPC.value) {

        //branchMissPredict = 1;

		regPC.setNewValue(newPC);
        mux1Src = newMux1Src;

        //
        // update branch target buffer
        //
        if (bpMode == BRANCH_PREDICTION) {

            //
            // remove "branch" entry if branch doesn't branch
            //
            if (newPC == regPC1.value + 4) {                        // {joj 1/11/06}

                if (btbIndex(regPC1.value) >= 0)                    // {joj 1/11/06}
                    btbPC[btbIndex(regPC1.value)].setInvalid(1);    // {joj 1/11/06}

            } else {

                //
                // re-use entry if present
                //
                if (btbIndex(regPC1.value) >= 0)					// {joj 1/11/06}
                    btbLast = btbIndex(regPC1.value)       	        // {joj 1/11/06}
                else
                    btbLast = (btbLast) ? 0 : 1;                    // {joj 1/2/06}

                btbPC[btbLast].setNewValue(regPC1.value);           // {joj 1/2/06}
                btbPC[btbLast].setInvalid(0);                       // {joj 1/2/06}
                btbPC[btbLast].useTag = 0;                          // {joj 1/2/06}
                btbPPC[btbLast].setNewValue(newPC);                 // {joj 1/2/06}

            }

        }

    }

}

//
// detectStall
//
function detectStall() {

    stall = NO_STALL;
    updateBTB = 0;

    // RAW hazards
    if (afMode == ALU_INTERLOCK) {

        if (instrOpTypeRdt(regEX.vIns) == OP_TYPE_REG) {
            if ((instrOpTypeRs1(regID.vIns) == OP_TYPE_REG) && (regID.vRs1 == regEX.vRdt))
                stall = DATA_STALL;
            if ((instrOpTypeRs2(regID.vIns) == OP_TYPE_REG) && (regID.vRs2 == regEX.vRdt))
                stall = DATA_STALL;
        }

        if (instrOpTypeRdt(regMA.vIns) == OP_TYPE_REG) {
            if ((instrOpTypeRs1(regID.vIns) == OP_TYPE_REG) && (regID.vRs1 == regMA.vRdt))
                stall = DATA_STALL;
            if ((instrOpTypeRs2(regID.vIns) == OP_TYPE_REG) && (regID.vRs2 == regMA.vRdt))
                stall = DATA_STALL;
        }

    }

    // RAW hazards (stores)
    if ((sfMode == STORE_INTERLOCK) && (regID.vIns == ST)) {        // {joj}

        //
        // NB: ST stores the value of Rdt into memory (Rs1 and Rs2 are used to specify the memory address)
        //
        if ((instrOpTypeRdt(regEX.vIns) == OP_TYPE_REG) && (regEX.vRdt == regID.vRdt))
            stall = DATA_STALL;
        if ((instrOpTypeRdt(regMA.vIns) == OP_TYPE_REG) && (regMA.vRdt == regID.vRdt))
            stall = DATA_STALL;

    }

    // RAW hazard (indirect jumps)
    if (instrIsJumpR(regID.vIns) && (instrIsBranch(regEX.vIns)==0)) {
        if ((instrOpTypeRdt(regEX.vIns) == OP_TYPE_REG) && (regEX.vRdt == regID.vRs2))
            stall = DATA_STALL;
        if ((instrOpTypeRdt(regMA.vIns) == OP_TYPE_REG) && (regMA.vRdt == regID.vRs2))
            stall = DATA_STALL;
    }

    // Load hazards
    if ((liMode == LOAD_INTERLOCK) && (regEX.vIns == LD)) {     // {joj}
        if ((instrOpTypeRs1(regID.vIns) == OP_TYPE_REG) && (regID.vRs1 == regEX.vRdt))
            stall = DATA_STALL;
        if ((instrOpTypeRs2(regID.vIns) == OP_TYPE_REG) && (regID.vRs2 == regEX.vRdt))
            stall = DATA_STALL;
    }

    if(instrIsMulti(regEX.vIns) && (multiStall==1)){
      stall = DATA_STALL;
    }

    // control hazards (real detection for control hazards is done in calcNewPC)
    //if ((stall == NO_STALL) && (bpMode != DELAYED_BRANCHES) && instrIsBranchOrJump(regID.vIns) && branchMissPredict) {	// {joj 1/2/06}
    if(instrIsBranch(regEX.vIns)){
      if(instrIsJump(regID.vIns) && (takeCondBranch==0) && (stall==NO_STALL)){
        updateBTB = 1;
        stall = CTRL_STALL;
      }
      else if (instrIsJump(regID.vIns) && (takeCondBranch==1) && (stall==NO_STALL)){
        stall = NO_STALL;
        condBranchStall = 1;
      }
      else if ((instrIsBranch(regID.vIns)==0) && (takeCondBranch==1) && (stall==NO_STALL)){
        updateBTB = 1;
        stall = CTRL_STALL;
      }
      else{
        stall = NO_STALL;
        condBranchStall = 0;
      }
    }
    else{
      if ((stall == NO_STALL) && (bpMode != DELAYED_BRANCHES) &&
        instrIsJump(regID.vIns) && (newPC != regPC.value)) {	// {joj 9/12/16}
      		updateBTB = 1;
          stall = CTRL_STALL;
      }
    }

    if (stall == DATA_STALL) {
        animClock.setStall(1, 0);
    } else if (stall == CTRL_STALL) {
        animClock.setStall(1, 1);
    }

}

function sendBTBOperands() {	// {joj 14/11/17}
    mux4Src.animate(18);		// {joj 3/11/12}
    apMUX4_BTB.animate(6);		// {joj 3/11/12}
}

//
// idExec
//
function idExec() {																// {joj 14/11/17}

    if (stall == NO_STALL) {
    	fork(regPC1.update());
        fork(regID.update());
    }
    if (condBranchStall==1){
      regID.setNewValue(STALL, 0, 0, 0);
      condBranchStall = 0;
    }

    if (updateBTB && (bpMode == BRANCH_PREDICTION))	{							// {joj 3/11/12}
        fork(btbPC[btbLast].update());											// {joj 1/2/06}
        fork(btbPPC[btbLast].update());											// {joj 1/2/06}
    }

    wait(16);

    fork(apID_EX.animate(64));

	//
	// BEQZ, BNEZ
	//
    //if (instrIsZeroBranch(regID.vIns) && (stall == NO_STALL)) {					// {joj 3/11/12}
  if (instrIsBranch(regID.vIns) ) {											// {joj 8/12/16}
    fork(apPC1_ADD4.animate(16));                          					// {joj 29/10/06}
    fork(ap4_ADD4.animate(16));                            					// {joj 29/10/06}
    fork(apPC1_ADDi.animate(16));                          					// {joj 29/10/06}
    fork(apID_ADDi.animate(16));
    fork(apRF_A.animate(16));
    fork(apRF_MUX5.animate(16));                          					// {joj 29/10/06}
    wait(12);                                                   			// {joj 29/10/06}
    txtID_ADDi.setTxt("%02X", regID.vRs2);                      			// {joj 29/10/06}
    txtID_ADDi.setOpacity(1);                                 				// {joj 29/10/06}
    wait(4);                                            					// {joj 29/10/06}
		fork(apADD4_MUX3.animate(8));                                 			// {joj 29/10/06}
		fork(apADDi_DM1.animate(8));
    wait(2);
    //if(instrIsBranch(regID.vIns)){
    //clDM1.setPen(controlHLPen);
    fork(apDM1_REGM.animate(8));
    regFile[regID.vRs1].highlight(bhighlight);                             // {joj}
    regA.setNewValue(regFile[regID.vRs1].value);
    regFile[regID.vRdt].highlight(bhighlight);                             // {joj}
    regB.setNewValue(regFile[regID.vRdt].value);
    fork(apMUX5_B.animate(5));
    wait(4);
    maybeR.setNewValue(regPC1.value + regID.vRs2);
    maybeR.update();
    // }
    // else{
    //   fork(apDM1_MUX3.animate(8));
    // }                                 			// {joj 29/10/06}
		//txtADD4_MUX3.setTxt("%02X", (regPC1.value + 4) & 0xff);             	// {joj 29/10/06}
		//txtADD4_MUX3.setOpacity(1, 8, 1, 0);                     	         	// {joj 29/10/06}
		//txtADDi_DM1.setTxt("%02X", (regPC1.value + regID.vRs2) & 0xff);    	// {joj 29/10/06}
		//txtADDi_DM1.setOpacity(1, 8, 1, 0);                              		// {joj 29/10/06}

	//
	// J, JAL
	//
	} else if (isJorJAL(regID.vIns)) {											// {joj 3/11/12}

		if (regID.vIns == JAL) {												// {joj 4/11/12}
			fork(apPC1_ADD4.animate(16));										// {joj 4/11/12}
  		fork(ap4_ADD4.animate(16));                            				// {joj 4/11/12}
		}

		if (stall == NO_STALL) {												// {joj 4/11/12}

			fork(apPC1_ADDi.animate(16));                          				// {joj 4/11/12}
    	fork(apID_ADDi.animate(16));                           				// {joj 4/11/12}
    	wait(12);                                           				// {joj 4/11/12}
    	txtID_ADDi.setTxt("%02X", regID.vRs2);                      		// {joj 4/11/12}
    	txtID_ADDi.setOpacity(1);                                 			// {joj 4/11/12}
    	wait(4);                                                   			// {joj 4/11/12}
			fork(apADDi_DM1.animate(8));
      wait(2);
      apDM1_MUX3.animate(8);
                                      		// {joj 4/11/12}
			//txtADDi_DM1.setTxt("%02X", (regPC1.value + regID.vRs2) & 0xff);	// {joj 4/11/12}
    	//txtADDi_DM1.setOpacity(1, 8, 1, 0);          						// {joj 4/11/12}

		} else {																// {joj 4/11/12}

			wait(24);															// {joj 4/11/12}

		}																		// {joj 4/11/12}

	//
	// JALR
	//
	} else if (regID.vIns == JALR) {											// {joj 4/11/12}

  		fork(apPC1_ADD4.animate(32));											// {joj 4/11/12}
    	fork(ap4_ADD4.animate(32));                            					// {joj 4/11/12}
   		wait(24);																// {joj 4/11/12}

  } else {
      wait(24);
  }
    //if(instrIsNonZeroBranch(regID.vIns) == 0)
  wait(9); // register file now updated {joj 4/11/12}

    //
    // second half of the clock cycle
    //
  if (instrIsJump(regID.vIns) || instrIsBranch(regEX.vIns))
      calcNewPC();

	//if (instrIsZeroBranch(regID.vIns) && (stall == NO_STALL)) {					// {joj 3/11/12}
	//if (instrIsZeroBranch(regID.vIns)) {											// {joj 9/12/16}
		//txtMUX3_MUX4.setTxt("%02X", newPC); 									// {joj 3/11/12}
		//txtMUX3_MUX4.setOpacity(1, 8, 1, 0);                           			// {joj 3/11/12}
	//}																			// {joj 3/11/12}

	if (instrIsJumpR(regID.vIns) && (stall == NO_STALL)) {						// {joj 4/11/12}
		txtRF_MUX1.setTxt("%02X", newPC); 										// {joj 4/11/12}
		txtRF_MUX1.setOpacity(1, 8, 1, 0);                           			// {joj 4/11/12}
	}

	//if (instrIsBranchOrJump(regID.vIns) && (stall == NO_STALL))				// {joj 4/11/12}
	if (instrIsBranchOrJump(regID.vIns))										// {joj 9/12/16}
       fork(sendBTBOperands());

  detectStall();
  takeCondBranch = 0;
	//debug("stall=%d", stall);
	if ((instrIsJump(regID.vIns) || instrIsBranch(regEX.vIns)) && (stall != DATA_STALL))				// {joj 10/12/16}
		updBTB();
															// {joj 9/12/16}

    if (stall == NO_STALL) {
      regEX.setNewValue(regID.vIns, regID.vRdt, regID.vRs1, regID.vRs2);
    } else if (condBranchStall==0 && multiStall==0){
      // if(regID.vIns == JAL){
      //   regEX.setNewValue(regID.vIns, regID.vRdt, regID.vRs1, regID.vRs2);
      // }
      // else{
        regEX.setNewValue(STALL, 0, 0, 0);
      //}
    }
    //if(instrIsNonZeroBranch(regID.vIns) == 0)
    wait(7);																	// {joj 4/11/12}

    // Send source registers to A and B
    if(instrIsBranch(regID.vIns) == 0){

      if (instrOpTypeRdt(regID.vIns) == OP_TYPE_REG) {

          if (instrIsJumpAndLink(regID.vIns)) {
            if(stall ==NO_STALL){
                regA.setNewValue(0);
                regB.setNewValue((regPC1.value + 4) & 0x7F);
                apADD4_MUX5.animate(18);
                apMUX5_B.animate(6);
            }
            else{
                regA.setNewValue(0);
                regB.setNewValue((regPC1.value + regID.vRs2) & 0x7F);
                apDM1_MUX5.animate(18);
                apMUX5_B.animate(6);
            }

          } else {

            regFile[regID.vRs1].highlight(bhighlight);                             // {joj}
            regA.setNewValue(regFile[regID.vRs1].value);

            // decision facilitated by the opcode format and does not need a MUX
            if (instrOpTypeRs2(regID.vIns) == OP_TYPE_REG) {
                regFile[regID.vRs2].highlight(bhighlight);                         // {joj}
                regB.setNewValue(regFile[regID.vRs2].value);
            } else {
                regFile[regID.vRdt].highlight(bhighlight);                         // {joj}
                regB.setNewValue(regFile[regID.vRdt].value);
            }

            txtRF_A.setTxt("R%d:%02X", regID.vRs1, regFile[regID.vRs1].value);      // {joj 29/10/06}
            txtRF_A.setOpacity(1);													// {joj}
            fork(apRF_A.animate(5));
            if(instrIsBranch(regID.vIns)){
              fork(apRF_MUX5.animate(5));
              apMUX5_B.animate(5);
            }

            //
            // read Register file B port
            // don't read if immediate addressing
            // don't read if LD
            // read destination register if ST
            // otherwise read source 2 register
            //
            if ((!instrIsArRI(regID.vIns)) && (regID.vIns != LD)) {     // {joj 28/10/06}
                num vr = (regID.vIns == ST) ? regID.vRdt : regID.vRs2;  // {joj 28/10/06}
                txtRF_MUX5.setTxt("R%d:%02X", vr, regFile[vr].value);   // {joj 29/10/06}
                txtRF_MUX5.setOpacity(1);								// {joj}
                apRF_MUX5.animate(18);                             		// {joj}
                apMUX5_B.animate(6);                               		// {joj}
            }

          }

      }
    }

}

//
// exExec
//
function exExec() {														// {joj 14/11/17}

  AnimPipe mux6Src, mux7Src, mux8Src;
  num op1, op2;

	fork(regEX.update());

	if (!instrIsNop(regEX.nIns)) {
        fork(regA.update());
        fork(regB.update());
  }

  wait(8);

  regMA.setNewValue(regEX.vIns, regEX.vRdt, regEX.vRs1, regEX.vRs2);

  if (instrOpTypeRdt(regEX.vIns) == OP_TYPE_REG) {

    // select correct source for operand 1
    if(instrIsMulti(regEX.vIns)){

        if(regEX.vIns == MUL){
          multiStall = 1;
          if(startMulti == 0){
            mux6Src = 0;
            //fork(apOUT0_MUX6.animate(20));
          }
        }
        else{
          if(startMulti == 0){
            if(multistage == CHECK){
               mux6Src = apOUT0_MUX6;
               op1 = regOUT0.value;
            }
            else if(multistage == EXEC){
              if(divDone == 0){
                mux6Src = apOUT1_MUX6;
                op1 = regOUT1.value;
              }
              else{
                mux6Src = 0;
              }
            }
          }
        }
    }



    // if(instrIsMulti(regEX.vIns)){
    //     multiStall = 1;
    //     if(startMulti == 1){
    //       if(regEX.vIns != MUL) divDone = 0;
    //       if(afMode == ALU_FORWARDING){
    //         if(regOUT0.tagMatches(regEX.vRs1)){
    //           op1 = regOUT0.value;
    //           fork(apOUT0_A.animate(20));
    //           regA.setNewValue(regOUT0.value);
    //           regA.update();
    //         }
    //         else if(regOUT1.tagMatches(regEX.vRs1)){
    //           op1 = regOUT1.value;
    //           fork(apOUT1_A.animate(20));
    //           regA.setNewValue(regOUT1.value);
    //           regA.update();
    //         }
    //         else{
    //           op1 = regA.value;
    //         }
    //         if(regOUT0.tagMatches(regEX.vRs2)){
    //           op2 = regOUT0.value;
    //           fork(apOUT0_B.animate(20));
    //           regB.setNewValue(regOUT0.value);
    //           regB.update();
    //         }
    //         else if(regOUT1.tagMatches(regEX.vRs2)){
    //           op2 = regOUT1.value;
    //           fork(apOUT1_B.animate(20));
    //           regB.setNewValue(regOUT1.value);
    //           regB.update();
    //         }
    //         else{
    //           op2 = regB.value;
    //         }
    //
    //       }
    //       else{
    //         op1 = regA.value;
    //         op2 = regB.value;
    //       }
    //       mux6Src = apA_MUX6;
    //     }
    //     else{
    //       if(multistage == CHECK){
    //         if(regEX.vIns == MUL){
    //           fork(apB_SUB1.animate(5));
    //           fork(ap1_SUB1.animate(5));
    //           regB.setNewValue(regB.value - 1);
    //           wait(2);
    //           regB.update();
    //           apSUB1_B.animate(5);
    //         }
    //         else{
    //           mux6Src = apOUT0_MUX6;
    //           // fork(apA_ADD1.animate(5));
    //           // fork(ap1_ADD1.animate(5));
    //           // regA.setNewValue(regA.value + 1);
    //           // wait(2);
    //           // regA.update();
    //           // apADD1_A.animate(5);
    //           op1 = regOUT0.value;
    //         }
    //         op2 = regB.value;
    //         mux7Src = apB_MUX7;
    //       }
    //       else if(multistage == EXEC){
    //         if(regEX.vIns == MUL){
    //           mux6Src = apA_MUX6;
    //           op1 = regA.value;
    //           mux7Src = apOUT1_MUX7;
    //           op2 = regOUT1.value;
    //         }
    //         else{
    //           if(divDone == 0){
    //             mux6Src = apOUT1_MUX6;
    //             op1 = regOUT1.value;
    //             mux7Src = apB_MUX7;
    //             op2 = regB.value;
    //             fork(apA_ADD1.animate(5));
    //             fork(ap1_ADD1.animate(5));
    //             regA.setNewValue(regA.value + 1);
    //             wait(2);
    //             regA.update();
    //             apADD1_A.animate(5);
    //           }
    //           else{
    //             mux6Src = apA_MUX6;
    //             op1 = regA.value;
    //           }
    //         }
    //       }
    //     }
    // }

      if (instrIsJumpAndLink(regEX.vIns)) {

          mux6Src = 0;    // Do not use MUX6 at all
          op1 = 0;

      } else if (afMode == ALU_FORWARDING) {
        if(!(instrIsMulti(regEX.vIns) && startMulti==0)){
            if (regOUT0.tagMatches(regEX.vRs1)) {
                mux6Src = apOUT0_MUX6;
                op1 = regOUT0.value;
            } else if (regOUT1.tagMatches(regEX.vRs1)) {
                mux6Src = apOUT1_MUX6;
                op1 = regOUT1.value;
            } else {
                mux6Src = apA_MUX6;
                op1 = regA.value;
            }
        }

      } else {
        if(!(instrIsMulti(regEX.vIns) && startMulti==0)){
            mux6Src = apA_MUX6;
            op1 = regA.value;
        }

      }

    // Choose correct source for operand 2
      if (instrIsJumpAndLink(regEX.vIns)) {

          mux7Src = apB_MUX7;
          op2 = regB.value;

      } else if (instrOpTypeRs2(regEX.vIns) == OP_TYPE_IMM) {

          if(instrIsBranch(regEX.vIns)) {

              if(afMode == ALU_FORWARDING){
                  if(regOUT0.tagMatches(regEX.vRdt)){
                    mux7Src = apOUT0_MUX7;
                    op2 = regOUT0.value;
                  }
                  else if(regOUT1.tagMatches(regEX.vRdt)){
                    mux7Src = apOUT1_MUX7;
                    op2 = regOUT1.value;
                  }
                  else{
                    mux7Src = apB_MUX7;
                    op2 = regB.value;
                  }
              }
              else {
                mux7Src = apB_MUX7;
                op2 = regB.value;
              }
          }
          else{
              mux7Src = apEX_MUX7;
              op2 = regEX.vRs2;
          }

      } else if (afMode == ALU_FORWARDING) {

        if(!(instrIsMulti(regEX.vIns) && startMulti==0)){
        //if(instrIsMulti(regEX.vIns)==0){
            if (regOUT0.tagMatches(regEX.vRs2)) {
                mux7Src = apOUT0_MUX7;
                op2 = regOUT0.value;
            } else if (regOUT1.tagMatches(regEX.vRs2)) {
                mux7Src = apOUT1_MUX7;
                op2 = regOUT1.value;
            } else {
                mux7Src = apB_MUX7;
                op2 = regB.value;
            }
        }

      } else {
        if(!(instrIsMulti(regEX.vIns) && startMulti==0)){
        //if(instrIsMulti(regEX.vIns)==0){
            mux7Src = apB_MUX7;
            op2 = regB.value;
        }

      }

      num result = 0;

      if(instrIsMulti(regEX.vIns)){

        if(regEX.vIns == MUL){
          if(startMulti == 1){
            if((op1 > 0x0F) || (op2 > 0x0F)){
              bit4mul = 0;
            }
            else{
              bit4mul = 1;
            }
            clALU1.setPen(controlHLPen);
            p1 = op1;
            p2 = 0;
            a = op2;
            calcNoCycles(op1);
            startMulti = 0;
            q1 = 0;
            result = op1;
          }
          else{
            if(bit4mul==1){
              booth();
              result = p1;
            }
            else{
              booth8();
              result = p1;
            }
            noCycles--;
            if(noCycles <= 0){
              multiStall = 0;
            }
          }

        }
        else{
          if(startMulti == 1){
            clALU1.setPen(controlHLPen);
            p1 = 0;
            a = op2;
            result = op1;
            startMulti = 0;
            multiStall = 1;
            multistage = CHECK;
          }
          else if (divDone == 0){
            if(multistage == CHECK){
              result = instrExecute(SLT, op1, a);
              if(result == 1){
                  divDone = 1;
                  if(regEX.vIns == REM) multiStall = 0;
              }
              multistage = EXEC;
              //p1 = 0;
            }
            else{
              result = instrExecute(SUB, op1, a);
              multistage = CHECK;
              p1 += 1;
            }
          }
          else{
            if(regEX.vIns == DIV){
              result = p1;
            }
            multiStall = 0;
          }

        }
        //if(prevOp1 >= prevOp2){
          // if(regEX.vIns == MUL){
          //   if(startMulti==1){
          //     result = op1;
          //   }
          //   else{
          //     if(multistage == CHECK){
          //       result = instrExecute(SLEi, op2, 0);
          //       clALU1.setPen(controlHLPen);
          //       if(result == 1){
          //         multiStall = 0;
          //       }
          //       else{
          //         multiStall = 1;
          //       }
          //       //multistage = EXEC;
          //     }
          //     else if(multistage = EXEC){
          //       result = instrExecute(ADD, op1, op2);
          //       //multistage = CHECK;
          //     }
          //   }
          // }
          // else{
          //   if(startMulti == 1){
          //     result = op1;
          //   }
          //   else if (divDone == 0){
          //     if(multistage == CHECK){
          //       result = instrExecute(SLT, op1, op2);
          //       if(result == 1){
          //           divDone = 1;
          //           if(regEX.vIns == REM) multiStall = 0;
          //       }
          //     }
          //     else{
          //       result = instrExecute(SUB, op1, op2);
          //     }
          //   }
          //   else{
          //     if(regEX.vIns == DIV){
          //       result = op1;
          //     }
          //     multiStall = 0;
          //   }
          // }
      }
      else
        result = instrExecute(regEX.vIns, op1, op2);

      // R0 is always 0
      if ((regEX.vRdt == 0) & (instrIsBranch(regEX.vIns)==0))
          result = 0;

      if(instrIsBranch(regEX.vIns) == 0){
        regOUT0.setNewValue(result);
        takeCondBranch = 0;
      }
      else{
        takeCondBranch = result;
      }

      if (instrIsLoadOrStore(regEX.vIns)) {
          regOUT0.setNewTag(-1);				// OUT0 contains the EA, tag should be -1
      } else {
        if((regEX.vIns==DIV || regEX.vIns==REM) && startMulti==0){
           if(multistage == EXEC){
             if(divDone == 0){
               regOUT0.setNewTag(0);
             }
             else{
               regOUT0.setNewTag(regEX.vRdt);
             }
             //multistage = EXEC;
           }
          else{
            regOUT0.setNewTag(regEX.vRdt);
            //multistage = CHECK;
          }
        }
        else{
          // if((regEX.vIns == JAL) && (stall == CTRL_STALL)) {
          //   regOUT0.setNewTag(8);
          // }
          // else{
            regOUT0.setNewTag(regEX.vRdt);
          //}
        }
  		}

      regOUT0.setInvalid(0);

  } else if (regEX.vIns == NOP) {				// {joj 30/11/16}
    //if(!(regMA.vIns==MUL)){
      	regOUT0.setInvalid(1);					// {joj 30/11/16}
      	regOUT0.updateLabel();					// {joj 30/11/16}
    // }
    // else{
    //   regOUT0.setNewTag(0);
    //   //regOUT0.updateLabel();
    // }

  }

    // For stores, send correct operand to SMDR
  if (regEX.vIns == ST) {  // {joj}
      if (sfMode == FORWARDING_TO_SMDR) {
          if (regOUT0.tagMatches(regEX.vRdt)) {
              mux8Src = apOUT0_MUX8;
              regSMDR.setNewValue(regOUT0.value);
          } else if (regOUT1.tagMatches(regEX.vRdt)) {
              mux8Src = apOUT1_MUX8;
              regSMDR.setNewValue(regOUT1.value);
          } else {
              mux8Src = apB_MUX8;
              regSMDR.setNewValue(regB.value);
          }
      } else {
          mux8Src = apB_MUX8;
          regSMDR.setNewValue(regB.value);
      }
  }

  wait(8);

  fork(apEX_MA.animate(64));

  if (regEX.vIns == ST)                                           // {joj}
      fork(mux8Src.animate(24));                            	 	// {joj 1/2/06}

  if (instrOpTypeRdt(regEX.vIns) == OP_TYPE_REG) {
      if (mux6Src != 0)
          fork(mux6Src.animate(24));
      if (mux7Src == apEX_MUX7) {                                 // {joj 29/10/06}
          txtEX_MUX7.setTxt("%02X", op2);                         // {joj 29/10/06}
          txtEX_MUX7.setOpacity(1);                             	// {joj 29/10/06}
      }                                                           // {joj 29/10/06}
      fork(mux7Src.animate(24));
  }

  wait(24);

  //
  // Second half of the clock cycle
  //

  if (regEX.vIns == ST)                                           // {joj}
      fork(apMUX8_SMDR.animate(40));                         		// {joj 1/2/06}

  if (instrOpTypeRdt(regEX.vIns) == OP_TYPE_REG) {

      if(regEX.vIns == MUL){
        alu.txtOp.setTxt(noCycles.toString());
        alu.txtOp.setOpacity(1);
      }
      else{
        alu.setTxtOp(regEX.vIns);
      }                                   // {joj 29/10/06}
      if (mux6Src != 0)
          fork(apMUX6_ALU.animate(10));
      if(instrIsMulti(regEX.vIns) && startMulti==1){
        if(regEX.vIns == MUL)
          startMulti = 0;
      }
      else if(!instrIsMulti(regEX.vIns)){
        fork(apMUX7_ALU.animate(10));
      }

      if(instrIsBranch(regEX.vIns)){
        //clALU1.setPen(controlHLPen);
        wait(5);
        if(takeCondBranch == 1)
          clALU2.setPen(controlHLPen);
      }
      else{
        if(((regEX.vIns == DIV) || (regEX.vIns == REM)) && (startMulti == 1)){
          //startMulti = 0;
          //clZeroA.setPen(controlHLPen);
          //regA.setNewValue(0);
          //wait(5);
          //regA.update();
        }
        wait(20);                                                   // {joj 29/10/06}
        apALU_OUT0.animate(10);
        wait(10);
        alu.txtResult.setTxt("%02X", result);                       // {joj 29/10/06}
        alu.txtResult.setOpacity(1, 20, 1, 0);                      // {joj 29/10/06}
      }

  }

  // take care of change to stack visualisation
  if(regEX.vIns == JAL){

    num spa = stack.spAddr;
    stack.currFrame++;
    stack.frames[stack.currFrame-1].setStart(spa);
    stack.setSP(spa);

  }
  if(regEX.vIns == JALR){
      stack.clearFrame();
  }

  if((instrOpTypeRdt(regEX.vIns) == OP_TYPE_REG) && (regEX.vIns != ST) && (regEX.vIns != LD)) {

    if((regEX.vRdt==2 && regMA.vRdt==8) && regMA.vIns==LD) {
      delayStackUpdate = 1;
    }
    else{
      if(regEX.vRdt == 2){
        stack.setSP(result);
      }
      else if(regEX.vRdt == 8){
        stack.setFP(result);
      }
    }
  }

}

//
// maExec - Memory Access phase
//
function maExec() {													// {joj 14/11/17}

    fork(regMA.update());

    if (instrOpTypeRdt(regMA.nIns) == OP_TYPE_REG)
        fork(regOUT0.update());

    if (regMA.nIns == ST) // {joj}
        fork(regSMDR.update());

    wait(8);

    regWB.setNewValue(regMA.vIns, regMA.vRdt, regMA.vRs1, regMA.vRs2);

    if ((instrOpTypeRdt(regMA.vIns) == OP_TYPE_REG) && (regMA.vIns != ST)) {  // {joj}

      if(instrIsAtomic(regMA.vIns) == 0){
          if (regMA.vIns == LD) {   // {joj}
              //regOUT1.setNewValue(memory[regOUT0.value % 4].value);
              regOUT1.setNewValue(stack.getVal(regOUT0.value));
              regOUT1.setNewTag(regMA.vRdt);
          } else {
              regOUT1.setNewValue(regOUT0.value);
              regOUT1.setNewTag(regOUT0.tag);
          }

          regOUT1.setInvalid(0);
      }
      else{
        string mess = hart.toString();
        //string mess2 = mess.concat(", ");
        //mess.concat(regMA.vIns.toString());
        sendToMem(mess, ", ", regMA.vIns.toString(), ", ", regOUT0.value.toString(), ", ", regSMDR.value.toString());
      }

    }

    wait(8);

    fork(apMA_WB.animate(64));

    if (regMA.vIns == ST) {                                         // {joj}

        //memory[regOUT0.value % 4].setNewValue(regSMDR.value);
        fork(apSMDR_Mem.animate(24));                          		// {joj 1/2/06}
        apOUT0_Mem.animate(24);
        //memory[regOUT0.value % 4].update();
        stack.store(regOUT0.value, regSMDR.value);

    } else if (instrOpTypeRdt(regMA.vIns) == OP_TYPE_REG) {

      if(instrIsAtomic(regMA.vIns)){

          if (regMA.vIns == LD) {                                     // {joj}
              apOUT0_Mem.animate(24);
              //memory[regOUT0.value % 4].highlight(bhighlight);		// {joj}
              stack.highlight(regOUT0.value % MEMORY_ADDRESSES);
              apMem_MUX9.animate(24);
              if(regMA.vRdt == 8){
                stack.setFP(stack.getVal(regOUT0.value));
              }
              else if(regMA.vRdt == 2){
                stack.setSP(stack.getVal(regOUT0.value));
              }
          } else {
              apOUT0_MUX9.animate(48);
              if(delayStackUpdate==1){
                if(regMA.vRdt == 2){
                  stack.setSP(regOUT0.value);
                }
                else if(regMA.vRdt == 8){
                  stack.setFP(regOUT0.value);
                }
                delayStackUpdate = 0;
              }
          }
          apMUX9_OUT1.animate(16);
      }

    }

}

//
// wbExec - write back phase
//
function wbExec() {																// {joj 14/11/17}

    fork(regWB.update());

    if ((instrOpTypeRdt(regWB.nIns) == OP_TYPE_REG) && (regWB.nIns != ST))      // {joj}
        fork(regOUT1.update());

    wait(8);

    if ((instrOpTypeRdt(regWB.vIns) == OP_TYPE_REG) && (regWB.vIns != ST)) {    // {joj}
        if(regOUT1.tag != 0){
            regFile[regOUT1.tag].setNewValue(regOUT1.value);
        }

        wait(8);

        apOUT1_RF.animate(24);

        //
        // Second half of the clock cycle
        //
        regFile[regOUT1.tag].update();
        wait(19);

    } else {

        wait(67);

    }

    if (regWB.vIns != STALL && regWB.vIns != EMPTY) {                   // {joj 30/10/06}
        instrCount++;                                                   // {joj 30/10/06}
        statIC.setTxt("%4d", instrCount);                               // {joj 30/10/06}
    }                                                                   // {joj 30/10/06}
    tickCount++;                                                        // {joj 30/10/06}
    statTE.setTxt("%4d", tickCount);                                    // {joj 30/10/06}

}

//
// nonPipelinedBranch
//
function nonPipelinedBranch() {										// {joj 14/11/11}

    fork(ap4_ADD4.animate(24));                                		// {joj 2/11/12}
    fork(apID_ADDi.animate(24));                               		// {joj 2/11/12}
	apPC_PC1.animate(12);											// {joj 2/11/12}
    fork(apPC1_ADD4.animate(12));									// {joj 2/11/12}
    fork(apPC1_ADDi.animate(12));									// {joj 2/11/12}
	wait(12);

  if (instrIsBranch(regEX.vIns)){
    regPC.setNewValue(maybeR.value & 0x7F);
    regPC.update();
    apMUX3_MUX1.animate(14);
  }
  else{

      if (instrIsJumpR(regID.vIns)) {
          regPC.setNewValue((regFile[regID.vRs2].value) & 0x7F);
          apRF_MUX1.animate(34);
      //}
      // else if (instrIsBranch(regID.vIns)) {
      //     if ((regFile[regID.vRs1].value == 0) == (regID.vIns == BEQZ)) {
      //         apADDi_DM1.animate(20);
      //         regPC.setNewValue((regPC.value + regID.vRs2) & 0x7F);
      //     } else {
      //         apADD4_MUX3.animate(20);
      //         regPC.setNewValue((regPC.value + 4) & 0x7F);
      //     }
      //     apMUX3_MUX1.animate(14);
      } else if (isJorJAL(regID.vIns)) {
          regPC.setNewValue((regPC.value + regID.vRs2) & 0x7F);
          apADDi_DM1.animate(20);
          apMUX3_MUX1.animate(14);
      } else {
          regPC.setNewValue((regPC.value + 4) & 0x7F);
          apADD4_MUX3.animate(20);
          apMUX3_MUX1.animate(14);
      }
    }

    apMUX1_PC.animate(6);

}

//
// execNonPipelined()
//
function execNonPipelined() {													// {joj 14/11/17}

    num regA, regB, result, smdr;

    // Update registers

    // IF

    regPC.update();
    im.setActive(regPC.newValue);

    apPC_IM.animate(24);

    apIM_ID.animate(40);                                             			// {joj 29/10/06}
    regID.setNewInstruction(im.instruction[regPC.value / 4]);                   // {joj 29/10/06}
    txtIM_ID.setTxt(regID.getNewInstrTxt());                                    // {joj 29/10/06}
    txtIM_ID.translate(60/2+70, 0, 20, 1, 0);                                   // {joj 29/10/06}

	/// ID

    regID.update();

    if ((instrOpTypeRs2(regID.vIns) == OP_TYPE_IMM) && (instrOpTypeRdt(regID.vIns) == OP_TYPE_REG))
        fork(apID_EX.animate(64));

    fork(nonPipelinedBranch());

    wait(24);

    /// Second half of the clock cycle

    if (instrIsJumpAndLink(regID.vIns)) {

        apADD4_MUX5.animate(20);
        apMUX5_B.animate(20);
        regA = 0;
        regB = (regPC.value + 4) & 0x7F;

    } else if (instrOpTypeRdt(regID.vIns) == OP_TYPE_REG) {

        regA = regFile[regID.vRs1].value;
        regFile[regID.vRs1].highlight(bhighlight);                                 // {joj}

        txtRF_A.setTxt("R%d:%02X", regID.vRs1, regFile[regID.vRs1].value);          // {joj 29/10/06}
        txtRF_A.setOpacity(1);                                                      // {joj}
        fork(apRF_A.animate(40));

        if ((instrOpTypeRs2(regID.vIns) == OP_TYPE_REG) || (regID.vIns == ST)) {    // {joj}

            if (instrOpTypeRs2(regID.vIns) == OP_TYPE_IMM) {
                regB = regFile[regID.vRdt].value;
                regFile[regID.vRdt].highlight(bhighlight);                     		// {joj}
            } else {
                regB = regFile[regID.vRs2].value;
                regFile[regID.vRs2].highlight(bhighlight);                    		 // {joj}
            }

            //
            // read Register file B port
            // don't read if immediate addressing
            // don't read if LD
            // read destination register if ST
            // otherwise read source 2 register
            //
            if ((!instrIsArRI(regID.vIns)) && (regID.vIns != LD)) {         // {joj 28/10/06}
                num vr = (regID.vIns == ST) ? regID.vRdt : regID.vRs2;      // {joj 28/10/06}
                txtRF_MUX5.setTxt("R%d:%02X", vr, regFile[vr].value);       // {joj 29/10/06}
                txtRF_MUX5.setOpacity(1);                                 	// {joj}
                apRF_MUX5.animate(20);                                 		// {joj}
                apMUX5_B.animate(20);                                  		// {joj}
            }                                                               // {joj}

        } else {

            wait(40);

        }

    } else {

        wait(40);

    }

    /// EX

    if (instrOpTypeRdt(regID.vIns) == OP_TYPE_REG)
        alu.setTxtOp(regID.vIns);                                           // {joj 29/10/06}

    if (regID.vIns == ST) {                                                 // {joj}

        fork(apB_MUX8.animate(40));
        fork(apA_MUX6.animate(40));
        txtEX_MUX7.setTxt("%02X", regID.vRs2);                              // {joj 29/10/06}
        txtEX_MUX7.setOpacity(1);                                           // {joj 29/10/06}
        apEX_MUX7.animate(40);                                         // {joj 28/10/06}

        fork(apMUX8_SMDR.animate(40));
        fork(apMUX7_ALU.animate(10));
        apMUX6_ALU.animate(10);
        wait(20);
        apALU_OUT0.animate(10);

        smdr = regB;
        result = instrExecute(regID.vIns, regA, regID.vRs2);

    } else if (instrIsJumpAndLink(regID.vIns)) {

        apB_MUX7.animate(40);
        apMUX7_ALU.animate(10);
        result = instrExecute(regID.vIns, regA, regB);
        wait(20);
        apALU_OUT0.animate(10);

    } else if (instrOpTypeRdt(regID.vIns) == OP_TYPE_REG) {

        fork(apA_MUX6.animate(40));

        if (instrOpTypeRs2(regID.vIns) == OP_TYPE_IMM) {
            txtEX_MUX7.setTxt("%02X", regID.vRs2);                          // {joj 29/10/06}
            txtEX_MUX7.setOpacity(1);                                     // {joj 29/10/06}
            apEX_MUX7.animate(40);
            result = instrExecute(regID.vIns, regA, regID.vRs2);
        } else {
            apB_MUX7.animate(40);
            result = instrExecute(regID.vIns, regA, regB);
        }

        fork(apMUX7_ALU.animate(10));
        apMUX6_ALU.animate(10);
        if(instrIsBranch(regID.vIns)){
          wait(5);
          clALU2.setPen(controlHLPen);
        }
        else{
          wait(20);
          apALU_OUT0.animate(10);
        }

    } else {

        wait(80);

    }

    /// MA

    if (regID.vIns == LD) {                                                 // {joj}
        apOUT0_Mem.animate(20);
        memory[(result) % 4].highlight(bhighlight);                        // {joj}
        apMem_MUX9.animate(20);
        apMUX9_OUT1.animate(40);
        result = memory[(result) % 4].value;
    } else if (regID.vIns == ST) {                                          // {joj}
        fork(apSMDR_Mem.animate(20));
        apOUT0_Mem.animate(20);
        memory[(result) % 4].setNewValue(smdr);
        memory[(result) % 4].update();
    } else if (instrOpTypeRdt(regID.vIns) == OP_TYPE_REG) {
        apOUT0_MUX9.animate(40);
        apMUX9_OUT1.animate(40);
    } else {
        wait(80);
    }

    /// WB

    regFile[0].unHighlight();
    regFile[1].unHighlight();
    regFile[2].unHighlight();
    regFile[3].unHighlight();

    if ((instrOpTypeRdt(regID.vIns) == OP_TYPE_REG) && (regID.vIns != ST)) {    // {joj}
        apOUT1_RF.animate(40);
        regFile[regID.vRdt].setNewValue(result);
        regFile[regID.vRdt].update();
        wait(19);
    } else {
        wait(75);
    }

    tickCount += 5;                                                     // {joj 30/10/06}
    instrCount++;                                                       // {joj 30/10/06}
    statIC.setTxt("%4d", instrCount);                                   // {joj 30/10/06}
    statTE.setTxt("%4d", tickCount);                                    // {joj 30/10/06}

}

function exec() {

    //
    // unhighlight registers
    //
    regFile[0].unHighlight();
    regFile[1].unHighlight();
    regFile[2].unHighlight();
    regFile[3].unHighlight();

    memory[0].unHighlight();
    memory[1].unHighlight();
    memory[2].unHighlight();
    memory[3].unHighlight();

    btbPC[0].unHighlight();                                                 // {joj 2/1/06}
    btbPC[1].unHighlight();                                                 // {joj 2/1/06}
    btbPPC[0].unHighlight();                                                // {joj 2/1/06}
    btbPPC[1].unHighlight();                                                // {joj 2/1/06}

    //
    // Run the individual pipeline phases
    //
    if (peMode == PIPELINING_ENABLED) {
        fork(ifExec());
 		fork(idExec());
        fork(exExec());
        fork(maExec());
        fork(wbExec());
    } else {
        fork(execNonPipelined());
    }

    wait(8);
    resetWires();

    wait((peMode == PIPELINING_ENABLED) ? 72 : 392);

    checkPoint();

}

// eof
