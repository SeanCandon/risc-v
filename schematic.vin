//
// schematic.vin
//
// Simulation of the DLX
// Written by Edsko de Vries, Summer 2003
//
// Copyright (C) 2003 - 2018 Edsko de Vries and jones@scss.tcd.ie
//
// This program is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation;
// either version 2 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//

string name = getArg("name", "");					// optional name of code example {joj 2/11/16}
if (name != "")
	name = sprintf(":  %s", name);					// {joj 2/10/16}}

Font fTitle = Font("Calibri", 20, SMALLCAPS | ITALIC);

Rectangle title = Rectangle2(0, HLEFT, 0, SolidBrush(DARK_BLUE), 0, 10, 200, 30, whitePen, fTitle, sprintf(" RISC-V ANIMATION %s", name));	// {joj 2/10/16}

Pen borderPen = SolidPen(DASH, 1, DARK_BLUE, ROUND_START | ROUND_JOIN | ROUND_END);

Line2(0, ABSOLUTE, borderPen, 110, 80, 740, 80);
Line2(0, ABSOLUTE, borderPen, 110, 440, 740, 440);

Line2(0, ABSOLUTE, borderPen, 110, 80, 110, 440);
Line b1 = Line2(0, ABSOLUTE, borderPen, 240, 80, 240, 440);
Line b2 = Line2(0, ABSOLUTE, borderPen, 390, 80, 390, 440);
Line b3 = Line2(0, ABSOLUTE, borderPen, 590, 80, 590, 440);
Line b4 = Line2(0, ABSOLUTE, borderPen, 690, 80, 690, 440);
Line2(0, ABSOLUTE, borderPen, 740, 80, 740, 440);

// Buttons

const num BUTTON_PE = 0;    // Pipeling enabled
const num BUTTON_BP = 1;    // Branch prediction
const num BUTTON_LI = 2;    // Load numerlock
const num BUTTON_AF = 3;    // ALU forwarding
const num BUTTON_SF = 4;    // SMDR forwarding
const num BUTTON_ZF = 5;    // Zero forwarding

const num BUTTON_SP = 6;    // Safe program

const num BUTTON_PAR = 7;

const num NUM_REGS = 32;
const num REG_WIDTH = 20;
const num REG_HEIGHT = 25;

Pen delimeter = SolidPen(DOT, THIN, BLACK);
Line2(0, ABSOLUTE, delimeter, 10, 450, 700, 450);

Font arialBold10 = Font("Calibri", 10, BOLD);

Button buttonSP = Button(20, 460, 70, 20, "Save Configuration", BUTTON_SP);            // {joj}
Button buttonPE = Button(100, 460, 70, 20, "Pipelining Enabled", BUTTON_PE);           // {joj}
Button buttonBP = Button(180, 460, 70, 20, "Branch Prediction", BUTTON_BP);            // {joj}
Button buttonLI = Button(260, 460, 70, 20, "Load Interlock", BUTTON_LI);               // {joj}
Button buttonAF = Button(340, 460, 70, 20, "ALU Forwarding", BUTTON_AF);               // {joj}
Button buttonSF = Button(420, 460, 70, 20, "Store Operand\nForwarding", BUTTON_SF);    // {joj}
Button buttonZF = Button(500, 460, 70, 20, "Zero Forwarding", BUTTON_ZF);
Button buttonPar = Button(580, 460, 70, 20, "Parallel", BUTTON_PAR);

//
// Vivio logo
//
// TODO: {joj 2/10.16}
//
const num LOGOW = 20;																	// 64 x 64 image
const num LOGOH = 20;
Image logo = Image(0, 0, 0, "vivio.png", 660,460, 0,0, LOGOW,LOGOH);					// {joj 24/9/17}

// Statistics

Txt(0, HLEFT | VTOP, 0, 46, darkGrayPen, font, "instructions executed:");		// {joj 25/7/10}
Rectangle et = Txt(0, HLEFT | VTOP, 0, 56, darkGrayPen, font, "ticks:");		// {joj}

Rectangle statIC = Txt(0, HLEFT | VTOP, 80, 46, redPen, font, "0");				// {joj}
Rectangle statTE = Txt(0, HLEFT | VTOP, 80, 56, redPen, font, "0");				// {joj}

// Instruction memory and clock
Rectangle imLabel = Rectangle2(0, 0, 0, 0, 0, 68, 100, 10, 0, font, "Instruction Cache"); // {joj}
InstructionMemory im = InstructionMemory(0, 80, 100, 320);
AnimatedClock animClock = AnimatedClock(0, 410, 80, 30);

// IF and PC
Register regPC = Register(200, 210, 20, 40, TOP, "PC");

// branch target buffer
Rectangle btbLabel  = Rectangle2(0, 0, 0, 0, 150, 85, 80, 10, 0, font, "Branch Target Buffer");    // {joj}
Register btbPC[2];										// {joj 2/10/16}
btbPC[0]  = Register(150, 100, 40, 20, LEFT, "PC");     // {joj 1/2/06}
btbPC[1]  = Register(150, 120, 40, 20, LEFT, "PC");     // {joj 1/2/06}
Register btbPPC[2];										// {joj 2/10/16}
btbPPC[0] = Register(190, 100, 40, 20, RIGHT, "PPC");   // {joj 1/2/06}
btbPPC[1] = Register(190, 120, 40, 20, RIGHT, "PPC");   // {joj 1/2/06}

// Other components
Component cMUX2 = Component(200, 170, 30, 10, "mux 2");       // {joj}
Component cMUX1 = Component(170, 205, 10, 50, "mux 1");       // {joj}
Component cPLUS4 = Component(160, 270, 20, 10, "+4");

// connections from and to instruction memory
AnimPipe apIM_ID = AnimPipe();
apIM_ID.addPoint(110, 390);
apIM_ID.addPoint(250, 390);
Rectangle txtIM_ID = Rectangle(activePipesLayer, 0, 0, redBrush, 180,390, -30,-6, 60,12, whitePen, font);	// {joj 1/4/06, 17/10/16}
txtIM_ID.setRounded(2, 2);	// {joj 17/10/16}

AnimPipe apPC_IM = AnimPipe();
apPC_IM.addPoint(210, 250);
apPC_IM.addPoint(210, 320);
apPC_IM.addPoint(110, 320);

// connections into MUX1
AnimPipe apMUX3_MUX1 = AnimPipe();
apMUX3_MUX1.addPoint(300, 170);
apMUX3_MUX1.addPoint(300, 160);
apMUX3_MUX1.addPoint(150, 160);
apMUX3_MUX1.addPoint(150, 215);
apMUX3_MUX1.addPoint(170, 215);

AnimPipe apBTB_MUX1 = AnimPipe();
apBTB_MUX1.addPoint(150, 120);
apBTB_MUX1.addPoint(140, 120);
apBTB_MUX1.addPoint(140, 225);
apBTB_MUX1.addPoint(170, 225);

AnimPipe apRF_MUX1 = AnimPipe();
//apRF_MUX1.addPoint(315, 50);
apRF_MUX1.addPoint(240, 50);
apRF_MUX1.addPoint(130, 50);
apRF_MUX1.addPoint(130, 235);
apRF_MUX1.addPoint(170, 235);

AnimPipe apADD4_MUX1 = AnimPipe();
apADD4_MUX1.addPoint(160, 275);
apADD4_MUX1.addPoint(120, 275);
apADD4_MUX1.addPoint(120, 245);
apADD4_MUX1.addPoint(170, 245);

// Connections to and from PC
AnimPipe apMUX1_PC = AnimPipe();
apMUX1_PC.addPoint(180, 230);
apMUX1_PC.addPoint(200, 230);

AnimPipe apPC_MUX2 = AnimPipe();
apPC_MUX2.addPoint(210, 210);
apPC_MUX2.addPoint(210, 180);

AnimPipe apPC_ADD4 = AnimPipe();
apPC_ADD4.addPoint(210, 250);
apPC_ADD4.addPoint(210, 275);
apPC_ADD4.addPoint(180, 275);

AnimPipe apPC_PC1 = AnimPipe();
apPC_PC1.addPoint(220, 230);
apPC_PC1.addPoint(240, 230);
apPC_PC1.addPoint(240, 230);

// MUX2 to BTB
AnimPipe apMUX2_BTB = AnimPipe();
apMUX2_BTB.addPoint(215, 170);
apMUX2_BTB.addPoint(215, 140);

//
// Instruction Decode
//
// ID to EX
//
AnimPipe apID_EX = AnimPipe();
apID_EX.addPoint(270, 390);
apID_EX.addPoint(390, 390);

// ID and PC1
InstructionRegister regID = InstructionRegister(250, 350, 20, 85, "ID");
Register regPC1 = Register(250, 210, 20, 40, TOP, "PC1");

// Register file
Txt(0, HLEFT | VTOP, 570, 40, 0, font, "Register\nFile");		// {joj}

Register regFile[NUM_REGS];
num xpos = 240;
num ypos = 25;
num pos = TOP;
for (i=0; i<NUM_REGS; i++){
	if (i == (NUM_REGS/2)) {
		pos = BOTTOM;
		xpos = 240;
		ypos += REG_HEIGHT;
	}
	string str = "x" + i.toString();
	regFile[i] = Register(xpos, ypos, REG_WIDTH, REG_HEIGHT, pos, str);
	xpos += REG_WIDTH;
}

// Other components
Component cMUX3 = Component(275, 170, 50, 10, "mux 3");                                               // {joj}
Component cADD4 = Component(270, 320, 30, 10, "ADD4");                                                // {joj}
Component cADDi = Component(300, 320, 30, 10, "ADDi");                                                //
Component cMUX4 = Component(250, 100, 10, 40, "mux 4");                                               // {joj}
Component cMUX5 = Component(375, 220, 10, 30, "mux 5");                                               // {joj}

Rectangle2(0, 0, 0, 0, 280, 365, 20, 10, 0, font, "4");

// Control lines for MUX3
Pen controlPen = SolidPen(SOLID, 0, PURPLE, ARROW60_END);
Pen controlHLPen = SolidPen(SOLID, 2, RED, ARROW60_END);
Pen muxPen = SolidPen(SOLID, MEDIUM, BLACK);															// {joj}

//zero input to alu for comparison during multiply operation
Rectangle cZeroTxt = Txt(valuesLayer,HLEFT | VTOP, 542, 376, 0, font, "zero");
Line clALU1 = Line2(valuesLayer, ABSOLUTE, controlPen, 550, 375, 550, 260);
Line clALU3 = Line2(valuesLayer, ABSOLUTE, controlPen,
	550, 375,
	550, 280,
	520, 280,
	520, 260,
	530, 260
);

Line clZeroA = Line2(valuesLayer, ABSOLUTE, controlPen,
	550, 360,
	410, 360,
	410, 220,
	420, 220
);

//output of ALU which determines whether branch should be taken
Line clALU2 = Line2(valuesLayer, ABSOLUTE, controlPen, 570, 220,
	580, 220,
	580, 150,
	385, 150,
	385, 175,
	325, 175
	);

// Connections from PC1
AnimPipe apPC1_MUX2 = AnimPipe();
apPC1_MUX2.addPoint(260, 210);
apPC1_MUX2.addPoint(260, 200);
apPC1_MUX2.addPoint(220, 200);
apPC1_MUX2.addPoint(220, 180);

AnimPipe apADD4_MUX5 = AnimPipe();
apADD4_MUX5.addPoint(285, 320);
apADD4_MUX5.addPoint(285, 240);
apADD4_MUX5.addPoint(375, 240);

AnimPipe apPC1_ADD4 = AnimPipe();
apPC1_ADD4.addPoint(260, 250);
apPC1_ADD4.addPoint(260, 345);
apPC1_ADD4.addPoint(290, 345);
apPC1_ADD4.addPoint(290, 330);

AnimPipe apPC1_ADDi = AnimPipe();
apPC1_ADDi.addPoint(260, 250);
apPC1_ADDi.addPoint(260, 345);
apPC1_ADDi.addPoint(310, 346);
apPC1_ADDi.addPoint(310, 330);

// Connections to and from the adders
AnimPipe ap4_ADD4 = AnimPipe();
ap4_ADD4.addPoint(290, 360);
ap4_ADD4.addPoint(290, 330);

AnimPipe apID_ADDi = AnimPipe();
apID_ADDi.addPoint(270, 390);
apID_ADDi.addPoint(320, 390);
apID_ADDi.addPoint(320, 330);
Rectangle txtID_ADDi = Rectangle(activePipesLayer, 0, 0, redBrush, 320,376, -12,-6, 24,12, whitePen, font);		// {joj 29/10/06, 17/10/16}
txtID_ADDi.setRounded(2, 2);	// {joj 17/10/16}

AnimPipe apADD4_MUX3 = AnimPipe();
apADD4_MUX3.addPoint(295, 320);
apADD4_MUX3.addPoint(295, 180);

Rectangle txtADD4_MUX3 = Rectangle(activePipesLayer, 0, 0, redBrush, 285,200, -12,-6, 24,12, whitePen, font);	// {joj 29/10/06, 15/3/15}
txtADD4_MUX3.setRounded(2, 2); // {joj 17/10/16}

AnimPipe apADDi_DM1 = AnimPipe();
apADDi_DM1.addPoint(315, 320);
apADDi_DM1.addPoint(315, 310);

AnimPipe apDM1_MUX3 = AnimPipe();
apDM1_MUX3.addPoint(307, 300);
apDM1_MUX3.addPoint(307, 180);
Rectangle txtDM1_MUX3 = Rectangle(activePipesLayer, 0, 0, redBrush, 315,200, -12,-6, 24,12, whitePen, font);	// {joj 29/10/06, 15/3/15}
txtDM1_MUX3.setRounded(2, 2);

AnimPipe apDM1_MUX5 = AnimPipe();
apDM1_MUX5.addPoint(307, 300);
apDM1_MUX5.addPoint(307, 240);
apDM1_MUX5.addPoint(375, 240);

AnimPipe apDM1_REGM = AnimPipe();
apDM1_REGM.addPoint(315, 300);
apDM1_REGM.addPoint(315, 280);
apDM1_REGM.addPoint(345, 280);

AnimPipe apREGM_MUX3 = AnimPipe();
apREGM_MUX3.addPoint(360, 270);
apREGM_MUX3.addPoint(360, 255);
apREGM_MUX3.addPoint(317, 255);
apREGM_MUX3.addPoint(317, 180);

Component cDEMUX1 = Component(297, 300, 40, 10, "demux 1");
Register maybeR = Register(345, 270, 30, 20, LEFT, "M");
maybeR.rotateLabel(90);                                           // {joj}

// Connection to BTB
AnimPipe apMUX3_MUX4 = AnimPipe();
apMUX3_MUX4.addPoint(300, 170);
apMUX3_MUX4.addPoint(300, 130);
apMUX3_MUX4.addPoint(260, 130);
Rectangle txtMUX3_MUX4 = Rectangle(activePipesLayer, 0, 0, redBrush, 300,160, -12,-6, 24,12, whitePen, font);	// {joj 29/10/06, 15/3/15}
txtMUX3_MUX4.setRounded(2, 2); // {joj 17/10/16}

AnimPipe apMUX4_BTB = AnimPipe();
apMUX4_BTB.addPoint(250, 120);
apMUX4_BTB.addPoint(230, 120);

AnimPipe apRF_MUX4 = AnimPipe();
apRF_MUX4.addPoint(240, 60);
apRF_MUX4.addPoint(220, 60);
apRF_MUX4.addPoint(220, 83);
apRF_MUX4.addPoint(280, 83);
apRF_MUX4.addPoint(280, 110);
apRF_MUX4.addPoint(260, 110);
Rectangle txtRF_MUX1 = Rectangle(activePipesLayer, 0, 0, redBrush, 200,44, -12,0, 24,12, whitePen, font);   // {joj 4/11/12}

// MUX5 to A
AnimPipe apMUX5_B = AnimPipe();
apMUX5_B.addPoint(385, 240);
apMUX5_B.addPoint(420, 240);

// Connections from the register file
AnimPipe apRF_MUX5 = AnimPipe();
apRF_MUX5.addPoint(360, 75);
apRF_MUX5.addPoint(360, 230);
apRF_MUX5.addPoint(375, 230);
Rectangle txtRF_MUX5 = Rectangle(activePipesLayer, 0, 0, redBrush, 340,82, -12,0, 24,12, whitePen, font, "R0:0");   // {joj 1/4/06, 17/10/16}
txtRF_MUX5.setRounded(2, 2);	// {joj 17/10/16}

AnimPipe apRF_A = AnimPipe();
apRF_A.addPoint(375, 75);
apRF_A.addPoint(375, 210);
apRF_A.addPoint(420, 210);
Rectangle txtRF_A = Rectangle(activePipesLayer, 0, 0, redBrush, 370,82, -12,0, 24,12, whitePen, font, "R0:0");      // {joj 1/4/06, 17/10/16}
txtRF_A.setRounded(2, 2);	// {joj 17/10/16}

//
// Execution
//
// EX, A and B
//
InstructionRegister regEX = InstructionRegister(390, 350, 20, 85, "EX");
Register regA = Register(420, 190, 20, 40, TOP, "A");
Register regB = Register(420, 230, 20, 40, BOTTOM, "B");

// Component cDECR = Component(328, 290, 23, 10, "SUB");
// Component cINCR = Component(337, 120, 23, 10, "ADD");

// AnimPipe apB_SUB1 = AnimPipe();
// apB_SUB1.addPoint(340, 260);
// apB_SUB1.addPoint(315, 260);
// apB_SUB1.addPoint(315, 295);
// apB_SUB1.addPoint(328, 295);
//
// AnimPipe apA_ADD1 = AnimPipe();
// apA_ADD1.addPoint(340, 200);
// apA_ADD1.addPoint(315, 200);
// apA_ADD1.addPoint(315, 125);
// apA_ADD1.addPoint(337, 125);

// Rectangle2(0, 0, 0, 0, 320, 315, 20, 10, 0, font, "-1");
// Rectangle2(0, 0, 0, 0, 320, 95, 20, 10, 0, font, "+1");

// AnimPipe ap1_SUB1 = AnimPipe();
// ap1_SUB1.addPoint(338, 320);
// ap1_SUB1.addPoint(345, 320);
// ap1_SUB1.addPoint(345, 300);
//
// AnimPipe ap1_ADD1 = AnimPipe();
// ap1_ADD1.addPoint(338, 100);
// ap1_ADD1.addPoint(345, 100);
// ap1_ADD1.addPoint(345, 120);
//
// AnimPipe apSUB1_B = AnimPipe();
// apSUB1_B.addPoint(345, 290);
// apSUB1_B.addPoint(345, 270);
//
// AnimPipe apADD1_A = AnimPipe();
// apADD1_A.addPoint(345, 130);
// apADD1_A.addPoint(345, 190);

// Other components
Component cMUX6 = Component(500, 180, 10, 50, "mux 6");   // {joj}
Component cMUX7 = Component(500, 230, 10, 50, "mux 7");   // {joj}
Component cMUX8 = Component(500, 310, 10, 40, "mux 8");   // {joj}
ALU alu = ALU(530, 190, 40, 80);

// EX to MA
AnimPipe apEX_MA = AnimPipe();
apEX_MA.addPoint(410, 390);
apEX_MA.addPoint(610, 390);

// Connections numo MUX6
AnimPipe apOUT0_MUX6 = AnimPipe();
apOUT0_MUX6.addPoint(610, 210);
apOUT0_MUX6.addPoint(610, 170);
apOUT0_MUX6.addPoint(470, 170);
apOUT0_MUX6.addPoint(470, 190);
apOUT0_MUX6.addPoint(500, 190);

AnimPipe apOUT0_LPAR = AnimPipe();
apOUT0_LPAR.addPoint(610, 210);
apOUT0_LPAR.addPoint(610, 100);
apOUT0_LPAR.addPoint(420, 100);
apOUT0_LPAR.addPoint(420, 115);

// AnimPipe apOUT0_A = AnimPipe();
// apOUT0_A.addPoint(530, 210);
// apOUT0_A.addPoint(530, 170);
// apOUT0_A.addPoint(355, 170);
// apOUT0_A.addPoint(355, 190);

AnimPipe apOUT1_MUX6 = AnimPipe();
apOUT1_MUX6.addPoint(710, 210);
apOUT1_MUX6.addPoint(710, 160);
apOUT1_MUX6.addPoint(460, 160);
apOUT1_MUX6.addPoint(460, 200);
apOUT1_MUX6.addPoint(500, 200);

// AnimPipe apOUT1_A = AnimPipe();
// apOUT1_A.addPoint(630, 210);
// apOUT1_A.addPoint(630, 160);
// apOUT1_A.addPoint(355, 160);
// apOUT1_A.addPoint(355, 190);

AnimPipe apA_MUX6 = AnimPipe();
apA_MUX6.addPoint(440, 220);
apA_MUX6.addPoint(500, 220);

// Connections numo MUX7
AnimPipe apB_MUX7 = AnimPipe();
apB_MUX7.addPoint(440, 240);
apB_MUX7.addPoint(500, 240);

AnimPipe apEX_MUX7 = AnimPipe();
apEX_MUX7.addPoint(410, 390);
apEX_MUX7.addPoint(450, 390);
apEX_MUX7.addPoint(450, 250);
apEX_MUX7.addPoint(500, 250);
Rectangle txtEX_MUX7 = Rectangle(activePipesLayer, 0, 0, redBrush, 432,370, -10,0, 20,12, whitePen, font, "IMM");	// {joj 1/4/06, 17/10/16}
txtEX_MUX7.setRounded(2, 2);	// {joj 17/10/16}

AnimPipe apOUT1_MUX7 = AnimPipe();
apOUT1_MUX7.addPoint(710, 250);
apOUT1_MUX7.addPoint(710, 300);
apOUT1_MUX7.addPoint(460, 300);
apOUT1_MUX7.addPoint(460, 260);
apOUT1_MUX7.addPoint(500, 260);

// AnimPipe apOUT1_B = AnimPipe();
// apOUT1_B.addPoint(630, 250);
// apOUT1_B.addPoint(630, 300);
// apOUT1_B.addPoint(355, 300);
// apOUT1_B.addPoint(355, 270);

AnimPipe apOUT0_MUX7 = AnimPipe();
apOUT0_MUX7.addPoint(610, 250);
apOUT0_MUX7.addPoint(610, 290);
apOUT0_MUX7.addPoint(470, 290);
apOUT0_MUX7.addPoint(470, 270);
apOUT0_MUX7.addPoint(500, 270);

// AnimPipe apOUT0_B = AnimPipe();
// apOUT0_B.addPoint(530, 250);
// apOUT0_B.addPoint(530, 290);
// apOUT0_B.addPoint(355, 290);
// apOUT0_B.addPoint(355, 270);

// Connectings to and from MUX8
AnimPipe apOUT0_MUX8 = AnimPipe();
apOUT0_MUX8.addPoint(610, 250);
apOUT0_MUX8.addPoint(610, 290);
apOUT0_MUX8.addPoint(470, 290);
apOUT0_MUX8.addPoint(470, 320);
apOUT0_MUX8.addPoint(500, 320);

AnimPipe apOUT1_MUX8 = AnimPipe();
apOUT1_MUX8.addPoint(710, 250);
apOUT1_MUX8.addPoint(710, 300);
apOUT1_MUX8.addPoint(460, 300);
apOUT1_MUX8.addPoint(460, 330);
apOUT1_MUX8.addPoint(500, 330);

AnimPipe apB_MUX8 = AnimPipe();
apB_MUX8.addPoint(435, 270);
apB_MUX8.addPoint(435, 340);
apB_MUX8.addPoint(500, 340);

AnimPipe apMUX8_SMDR = AnimPipe();
apMUX8_SMDR.addPoint(510, 330);
apMUX8_SMDR.addPoint(600, 330);

//
// Connections from MUX6 through the ALU to OUT0
//
AnimPipe apMUX6_ALU = AnimPipe();
apMUX6_ALU.addPoint(510, 210);
apMUX6_ALU.addPoint(530, 210);
// apMUX6_ALU.addPoint(510, 230);
// apMUX6_ALU.addPoint(560, 230);

AnimPipe apMUX7_ALU = AnimPipe();
apMUX7_ALU.addPoint(510, 250);
apMUX7_ALU.addPoint(530, 250);
// apMUX7_ALU.addPoint(510, 230);
// apMUX7_ALU.addPoint(560, 230);

AnimPipe apALU_OUT0 = AnimPipe();
apALU_OUT0.addPoint(570, 240);
apALU_OUT0.addPoint(600, 240);

//
// Memory access
//
// MA, SMDR and OUT0
//
InstructionRegister regMA = InstructionRegister(610, 350, 20, 85, "MA");
Register regOUT0 = Register(600, 210, 20, 40, TOP, "O0");
Register regSMDR = Register(600, 320, 40, 20, RIGHT, "SMR");
Txt(valuesLayer, HLEFT | VTOP, 658, 120, 0, font, "memory\naddress");        // {joj}
Txt(valuesLayer, HLEFT | VTOP, 755, 300, 0, font, "memory\ndata-in");        // {joj}
Txt(valuesLayer, HLEFT | VTOP, 755, 65, 0, font, "memory\ndata-out");       // {joj}

Register regLPAR = Register(400, 115, 40, 30, LEFT, "LPAR");
Register regLF = Register(510, 115, 20, 30, TOP, "LF");
Line clALU4 = Line2(valuesLayer, ABSOLUTE, controlPen,
	520, 145,
	520, 200,
	530, 200
);

// AnimPipe apZero_LF = AnimPipe();
// apZero_LF.addPoint(550, 120);
// apZero_LF.addPoint(530, 120);
// Txt(valuesLayer, HLEFT | VTOP, 552, 115, 0, font, "0");

AnimPipe apOne_LF = AnimPipe();
apOne_LF.addPoint(550, 130);
apOne_LF.addPoint(530, 130);
Rectangle oneTxt = Txt(valuesLayer, HLEFT | VTOP, 552, 125, 0, font, "1");

Rectangle comparitor = Rectangle2(0, 0, blackPen, yellowBrush, 470, 120, 20, 20, blackPen, componentFont, sprintf("="));
comparitor.setRounded(2, 2);

AnimPipe apLPAR_Comp = AnimPipe();
apLPAR_Comp.addPoint(440, 135);
apLPAR_Comp.addPoint(470, 135);

AnimPipe apComp_LF = AnimPipe();
apComp_LF.addPoint(490, 130);
apComp_LF.addPoint(510, 130);

// Stack
Stack stack = Stack(800, 60);

//stack.setFP(10);
//stack.createFrame(2, 1);

//Memory Bus
Rectangle busLabel = Rectangle2(0, 0, whitePen, whiteBrush, 795, 10, 10, 10, blackPen, font, sprintf("Memory Bus"));
busLabel.setOpacity(0);
Rectangle toFromMem = Rectangle2(0, 0, whitePen, whiteBrush, 880, 230, 10, 10, blackPen, font, sprintf("to/from memory"));
toFromMem.setOpacity(0);
Rectangle busBusyLabel = Rectangle2(0, 0, whitePen, whiteBrush, 880, 180, 10, 10, redPen, font, sprintf("Bus Busy"));
busBusyLabel.setOpacity(0);


AnimPipe apBus1 = AnimPipe();
apBus1.resize(20);
apBus1.addPoint(800, 70);
apBus1.addPoint(800, 450);
AnimPipe apBus2 = AnimPipe();
apBus2.resize(20);
apBus2.addPoint(800, 410);
apBus2.addPoint(800, 30);
apBus1.setOpacity(0);
apBus2.setOpacity(0);

AnimPipe apToMem = AnimPipe();
apToMem.resize(10);
apToMem.addPoint(810, 250);
apToMem.addPoint(950, 250);
apToMem.setOpacity(0);

//
// Other components
//
Component cMUX9 = Component(670, 210, 10, 40, "mux 9");                                                   // {joj}

// MA to WB
AnimPipe apMA_WB = AnimPipe();
apMA_WB.addPoint(630, 390);
apMA_WB.addPoint(700, 390);

// OUT0 to MUX 8/OUT1
//
AnimPipe apOUT0_MUX9 = AnimPipe();
apOUT0_MUX9.addPoint(620, 230);
apOUT0_MUX9.addPoint(670, 230);

AnimPipe apMUX9_OUT1 = AnimPipe();
apMUX9_OUT1.addPoint(680, 230);
apMUX9_OUT1.addPoint(700, 230);

AnimPipe apOUT0_Mem = AnimPipe();
apOUT0_Mem.addPoint(620, 230);
apOUT0_Mem.addPoint(630, 230);
apOUT0_Mem.addPoint(630, 110);
apOUT0_Mem.addPoint(800, 110);

AnimPipe apSMDR_Mem = AnimPipe();
apSMDR_Mem.addPoint(640, 330);
apSMDR_Mem.addPoint(800, 330);

AnimPipe apMem_MUX9 = AnimPipe();
apMem_MUX9.addPoint(800, 90);
apMem_MUX9.addPoint(650, 90);
apMem_MUX9.addPoint(650, 220);
apMem_MUX9.addPoint(670, 220);

AnimPipe apMem_Comp = AnimPipe();
apMem_Comp.addPoint(800, 90);
apMem_Comp.addPoint(450, 90);
apMem_Comp.addPoint(450, 125);
apMem_Comp.addPoint(470, 125);


//
// Write Back
//

// WB and OUT1

InstructionRegister regWB = InstructionRegister(700, 350, 20, 85, "WB");
Register regOUT1 = Register(700, 210, 20, 40, TOP, "O1");

// Connections from OUT1 to the register file

AnimPipe apOUT1_RF = AnimPipe();
apOUT1_RF.addPoint(720, 230);
apOUT1_RF.addPoint(730, 230);
apOUT1_RF.addPoint(730, 10);
apOUT1_RF.addPoint(470, 10);
apOUT1_RF.addPoint(470, 25);

alu.txtResult.moveToFront();                            // {joj 29/10/06}

parallelMode();

//
// ResetWires
//
function resetWires() {

	//
	// IF
	//
    apPC_IM.reset();
    apIM_ID.reset();
    txtIM_ID.setOpacity(0);                             // {joj 29/10/06}
    //apIF_ID.reset();
    apMUX3_MUX1.reset();
    apBTB_MUX1.reset();
    apRF_MUX1.reset();
    apADD4_MUX1.reset();
    apMUX1_PC.reset();
    apPC_MUX2.reset();
    apPC_ADD4.reset();
    apPC_PC1.reset();
    apMUX2_BTB.reset();

    //
	// ID
	//
    apID_EX.reset();
    apPC1_MUX2.reset();
    //apPC1_MUX5.reset();
    apADD4_MUX5.reset();
    apPC1_ADD4.reset();
    apPC1_ADDi.reset();
    ap4_ADD4.reset();
    apID_ADDi.reset(); txtID_ADDi.setOpacity(0);            // {joj 29/10/06}
    apADD4_MUX3.reset(); txtADD4_MUX3.setOpacity(0);        // {joj 29/10/06}
    apDM1_MUX3.reset(); txtDM1_MUX3.setOpacity(0);
		apDM1_MUX5.reset();
		apDM1_REGM.reset();     // {joj 29/10/06}
		apREGM_MUX3.reset();
		apADDi_DM1.reset();
    apMUX3_MUX4.reset(); txtMUX3_MUX4.setOpacity(0);        // {joj 29/10/06}
    apRF_MUX4.reset();
    apMUX4_BTB.reset();
    apMUX5_B.reset();
    apRF_MUX5.reset(); txtRF_MUX5.setOpacity(0);            // {joj}
    apRF_A.reset(); txtRF_A.setOpacity(0);                  // {joj}
    txtRF_MUX1.setOpacity(0);								// {joj 4/11/12}
	//clALU.setPen(controlPen);
    //clOUT0.setPen(controlPen);
    //clOUT1.setPen(controlPen);
    //clA.setPen(controlPen);
    //clMUX.setPen(controlPen);

		clALU1.setPen(controlPen);
		clZeroA.setPen(controlPen);
		clALU2.setPen(controlPen);
		clALU3.setPen(controlPen);

		clALU4.setPen(controlPen);
		//clDM1.setPen(controlPen);

    //
    // EX
    //
    apEX_MA.reset();
    apOUT0_MUX6.reset();
    apOUT1_MUX6.reset();
		//apOUT0_A.reset();
		//apOUT1_A.reset();
    apA_MUX6.reset();
    apB_MUX7.reset();
    apEX_MUX7.reset(); txtEX_MUX7.setOpacity(0);        // {joj 29/10/06}
    apOUT1_MUX7.reset();
    apOUT0_MUX7.reset();
    apOUT0_MUX8.reset();
    apOUT1_MUX8.reset();
    apB_MUX8.reset();
		//apB_SUB1.reset();
		//ap1_SUB1.reset();
		//apSUB1_B.reset();
		//apA_ADD1.reset();
		//ap1_ADD1.reset();
		//apADD1_A.reset();
    apMUX8_SMDR.reset();
    apMUX6_ALU.reset();
    apMUX7_ALU.reset();
		apALU_OUT0.reset();

		//apZero_LF.reset();
		apOne_LF.reset();

		apLPAR_Comp.reset();
		apMem_Comp.reset();
		apComp_LF.reset();
		//apOUT1_B.reset();
		//apOUT0_B.reset();
    alu.txtOp.setOpacity(0);                            // hide ALU txtOp {joj 29/10/06}
    alu.txtResult.setOpacity(0);                        // hide ALU txtResult {joj 29/10/06}

		clALU1.setPen(controlPen);
		clZeroA.setPen(controlPen);
    //
    // MA
    //
    apMA_WB.reset();
    apOUT0_MUX9.reset();
    apMUX9_OUT1.reset();
    apOUT0_Mem.reset();
    apSMDR_Mem.reset();
    apMem_MUX9.reset();

		apOUT0_LPAR.reset(); //apOUT0_LPAR.setOpacity(0);
		//apOUT0_LF.reset();	//apOUT0_LF.setOpacity(0);

		apBus1.reset();	//apBus1.setOpacity(0);
		apBus2.reset();	//apBus2.setOpacity(0);
		apToMem.reset(); //apToMem.setOpacity(0);

    //
    // WB
    //
    apOUT1_RF.reset();

}

function parallelMode(){
	if(parallel == 1){
		stack.setAll(0);
		apBus1.setOpacity(1);
		apBus2.setOpacity(1);
		apToMem.setOpacity(1);
		busLabel.setOpacity(1);
		toFromMem.setOpacity(1);
		// apOUT0_LPAR.setOpacity(1);
		// apOUT0_LF.setOpacity(1);
		// regLPAR.setOpacity(1);
		// regLF.setOpacity(1);
		// clALU4.setPen(controlPen);
	}
	else{
		stack.setAll(1);
		apBus1.setOpacity(0);
		apBus2.setOpacity(0);
		apToMem.setOpacity(0);
		busLabel.setOpacity(0);
		toFromMem.setOpacity(0);
		// apOUT0_LPAR.setOpacity(0);
		// apOUT0_LF.setOpacity(0);
		// regLPAR.setOpacity(0);
		// regLF.setOpacity(0);
		// clALU4.setPen(whitePen);
	}
}

//
// resetRegisters()
//
function resetRegisters() {

    regPC.reset(); regPC.setValue(0x7C);
    regPC1.reset();
    regA.reset();
    regB.reset();
    regSMDR.reset();
    regOUT0.reset();
    regOUT1.reset();

    btbPC[0].reset();               // {joj 1/2/06}
    btbPC[1].reset();               // {joj 1/2/06}
    btbPPC[0].reset();              // {joj 1/2/06}
    btbPPC[1].reset();              // {joj 1/2/06}

    regID.reset();
    regEX.reset();
    regMA.reset();
    regWB.reset();

    im.setActive(0x7C);

    regOUT0.setInvalid(1);
    regOUT0.updateLabel();
    regOUT1.setInvalid(1);
    regOUT1.updateLabel();
    btbPC[0].setValue(-1);          // {joj 1/2/06} - was (-1) & 0xFF
    btbPC[0].setInvalid(1);         // {joj 1/2/06}
    btbPC[0].updateLabel();         // {joj 1/2/06}
    btbPC[1].setValue(-1);          // {joj 1/2/06} - was (-1) & 0xFF
    btbPC[1].setInvalid(1);         // {joj 1/2/06}
    btbPC[1].updateLabel();         // {joj 1/2/06}

    instrCount = 0;
    tickCount = 0;

    statIC.setTxt("%4d", 0);        // {joj}
    statTE.setTxt("%4d", 0);        // {joj}

		// regLPAR.setOpacity(0);
		// regLF.setOpacity(0);

}

function resetCircuit() {
    resetRegisters();
    resetWires();
}

//
// Enabling and disabling parts of the pipeline
//
function showBTB(num opacity) {

    btbLabel.setOpacity(opacity);
    btbPC[0].setOpacity(opacity);   // {joj 1/2/06}
    btbPC[1].setOpacity(opacity);   // {joj 1/2/06}
    btbPPC[0].setOpacity(opacity);  // {joj 1/2/06}
    btbPPC[1].setOpacity(opacity);  // {joj 1/2/06}

    apPC_MUX2.setOpacity(opacity);
    apPC1_MUX2.setOpacity(opacity);
    cMUX2.setOpacity(opacity);
    apMUX2_BTB.setOpacity(opacity);

    apBTB_MUX1.setOpacity(opacity);

    apMUX3_MUX4.setOpacity(opacity);
    apRF_MUX4.setOpacity(opacity);
    cMUX4.setOpacity(opacity);
    apMUX4_BTB.setOpacity(opacity);

}

//
// showALUForwarding
//
function showALUForwarding(num opacity) {  // {joj 20/8/10}

    if (opacity == 0) {

        //
        // NOT pipelined
        //
        apA_MUX6.setPoint(0, 440, 210);
        apA_MUX6.setPoint(1, 510, 210);

        apB_MUX7.setPoint(0, (afMode) ? 440 : 430, 240);    // {joj 28/10/06}
        apB_MUX7.setPoint(1, 500, 240);

        apEX_MUX7.setPoint(2, 450, 260);
        apEX_MUX7.setPoint(3, 500, 260);

        apA_MUX6.setHead(0);

    } else {

        apA_MUX6.setPoint(0, 440, 220);
        apA_MUX6.setPoint(1, 500, 220);

        apB_MUX7.setPoint(0, 440, 240);
        apB_MUX7.setPoint(1, 500, 240);

        apEX_MUX7.setPoint(2, 450, 250);
        apEX_MUX7.setPoint(3, 500, 250);

        apA_MUX6.setHead(1);

    }

    cMUX6.setOpacity(opacity);
    apOUT0_MUX6.setOpacity(opacity);
    apOUT1_MUX6.setOpacity(opacity);

    apOUT0_MUX7.setOpacity(opacity);
    apOUT1_MUX7.setOpacity(opacity);

}

//
// showSMDRForwarding
//
function showSMDRForwarding(num opacity) { // {joj 20/8/10}

    if (opacity == 0) {

        apB_MUX8.setPoint(1, 435, 330);
        apB_MUX8.setPoint(2, 510, 330);
        apB_MUX8.setHead(0);

    } else {

        apB_MUX8.setPoint(1, 435, 340);
        apB_MUX8.setPoint(2, 500, 340);
        apB_MUX8.setHead(1);

    }

    cMUX8.setOpacity(opacity);
    apOUT0_MUX8.setOpacity(opacity);
    apOUT1_MUX8.setOpacity(opacity);

}

function showParallelComponents(num opacity){
	regLPAR.setOpacity(opacity);
	regLF.setOpacity(opacity);
	apOUT0_LPAR.setOpacity(opacity);
	apLPAR_Comp.setOpacity(opacity);
	apOne_LF.setOpacity(opacity);
	apMem_Comp.setOpacity(opacity);
	comparitor.setOpacity(opacity);
	apComp_LF.setOpacity(opacity);
	oneTxt.setOpacity(opacity);
	clALU4.setOpacity(opacity);
}

//
// showZeroForwarding
//
function showZeroForwarding(num opacity) { // {joj 20/8/10}

    if (opacity == 0) {
        //clA.setPt(1, -15, 0);				// {joj 15/3/15}
        //clA.setPt(2, -15, 25);			// {joj 15/3/15}
        //clA.setPt(1, 325, 135);				// {joj 5/10/16}
        //clA.setPt(2, 325, 160);				// {joj 5/10/16}
    } else {
		//clA.setPt(1, -25, 0);				// {joj 15/3/15}
        //clA.setPt(2, -25, 25);			// {joj 15/3/15}
		//clA.setPt(1, 315, 135);				// {joj 5/10/16}
        //clA.setPt(2, 315, 160);				// {joj 5/10/16}

   }

    //cZeroMux.setOpacity(opacity);
    //cZeroTxt.setOpacity(opacity);
    //clALU.setOpacity(opacity);
    //clOUT0.setOpacity(opacity);
    //clOUT1.setOpacity(opacity);

}

//
// showPipeline
//
function showPipeline(num opacity) {   // {joj 20/8/10}

    if (opacity == 0) {

        //
        // not pipelined
        //
        apPC_PC1.setPoint(1, 260, 230);
        apPC_PC1.setPoint(2, 260, 240);

        apPC1_ADD4.setPoint(0, 260, 230);
        apPC1_ADDi.setPoint(0, 260, 230);

        apID_EX.setPoint(1, 410, 390);

        apRF_A.setPoint(1, 375, 210);
        apRF_A.setPoint(2, 440, 210);
        apMUX5_B.setPoint(1, 440, 240);             // {joj 28/10/06}
        apB_MUX8.setPoint(0, 435, 240);

				apB_MUX7.setPoint(0, 440, 240);

        //apMUX6_ALU.setPoint(3, 580, 230);
        //apMUX7_ALU.setPoint(3, 580, 230);
				apALU_OUT0.setPoint(0, 570, 230);
				apALU_OUT0.setPoint(1, 620, 230);

        apMUX8_SMDR.setPoint(1, 640, 330);
        apMUX9_OUT1.setPoint(1, 720, 230);

        apID_EX.setHead(0);
        apPC_PC1.setHead(0);
        apRF_A.setHead(0);
        apA_MUX6.setHead(0);
        apMUX5_B.setHead(0);
        apB_MUX8.setHead(0);
        apMUX8_SMDR.setHead(0);
        apMUX6_ALU.setHead(0);
        apMUX7_ALU.setHead(0);
				apALU_OUT0.setHead(0);
        apMUX9_OUT1.setHead(0);

        showBTB(opacity);
        showALUForwarding(opacity);
        showSMDRForwarding(opacity);
        showZeroForwarding(opacity);
				showParallelComponents(opacity);

				clZeroA.setOpacity(opacity);

    } else {

        apPC_PC1.setPoint(1, 240, 230);
        apPC_PC1.setPoint(2, 250, 230);

        apPC1_ADD4.setPoint(0, 260, 250);
        apPC1_ADDi.setPoint(0, 260, 250);

        apID_EX.setPoint(1, 390, 390);

        apRF_A.setPoint(1, 375, 210);
        apRF_A.setPoint(2, 420, 210);
        apMUX5_B.setPoint(1, 420, 240);
        apB_MUX8.setPoint(0, 435, 270);

        //apMUX6_ALU.setPoint(3, 560, 230);
        //apMUX7_ALU.setPoint(3, 560, 230);
				//apALU_OUT0.setPoint(3, 600, 240);
				apALU_OUT0.setPoint(0, 570, 240);
				apALU_OUT0.setPoint(1, 600, 240);

        apMUX8_SMDR.setPoint(1, 600, 330);
        apMUX9_OUT1.setPoint(1, 700, 230);

        apID_EX.setHead(1);
        apPC_PC1.setHead(1);
        apRF_A.setHead(1);
        apA_MUX6.setHead(1);
        apMUX5_B.setHead(1);
        apB_MUX8.setHead(1);
        apMUX8_SMDR.setHead(1);
        apMUX6_ALU.setHead(1);
        apMUX7_ALU.setHead(1);
				apALU_OUT0.setHead(1);
        apMUX9_OUT1.setHead(1);

        showBTB(bpMode == BRANCH_PREDICTION ? 1 : 0);
        showALUForwarding(afMode == ALU_FORWARDING ? 1 : 0);
        showSMDRForwarding(sfMode == FORWARDING_TO_SMDR ? 1 : 0);
        showZeroForwarding(zfMode == ZERO_FORWARDING ? 1 : 0);
				showParallelComponents(opacity);

				clZeroA.setOpacity(opacity);

    }

    apPC_ADD4.setOpacity(opacity);
    cPLUS4.setOpacity(opacity);
    apADD4_MUX1.setOpacity(opacity);

    regPC1.setOpacity(opacity);
    regEX.setOpacity(opacity);
    regMA.setOpacity(opacity);
    regWB.setOpacity(opacity);

    apEX_MA.setOpacity(opacity);
    apMA_WB.setOpacity(opacity);

    regA.setOpacity(opacity);
    regB.setOpacity(opacity);
    regOUT0.setOpacity(opacity);
    regOUT1.setOpacity(opacity);
    regSMDR.setOpacity(opacity);

    buttonBP.label.setOpacity(opacity);
    buttonLI.label.setOpacity(opacity);
    buttonAF.label.setOpacity(opacity);
    buttonSF.label.setOpacity(opacity);
    buttonZF.label.setOpacity(opacity);
		buttonPar.label.setOpacity(opacity);

}

//
// setPEMode
//
function setPEMode(num mode) {
    peMode = mode;
    if (peMode == 0) {
        buttonPE.setCaption("Pipelining Enabled");
        showPipeline(1);
    } else if (peMode == 1) {
        buttonPE.setCaption("Pipelining Disabled");
        showPipeline(0);
    }
    setArg("peMode", peMode.toString()); // {joj 6/11/16}
}

//
// setBPMode
//
function setBPMode(num mode) {
    bpMode = mode;
    if (bpMode == 0) {
        buttonBP.setCaption("Branch Prediction");
        showBTB(1);
    } else if (bpMode == 1) {
        buttonBP.setCaption("Branch Interlock");
        showBTB(0);
    } else if (bpMode == 2) {
        buttonBP.setCaption("Delayed Branches");
        showBTB(0);
    }
    setArg("bpMode", bpMode.toString()); // {joj 6/11/16}
}

//
// setLIMode
//
function setLIMode(num mode) {
    liMode = mode;
    if (liMode == 0) {
        buttonLI.setCaption("Load Interlock");
    } else if (liMode == 1) {
        buttonLI.setCaption("No Load Interlock");
    }
    setArg("liMode", liMode.toString()); // {joj 6/11/16}
}

//
// setAFMode
//
function setAFMode(num mode) {
    afMode = mode;
    if (afMode == 0) {
        buttonAF.setCaption("ALU Forwarding");
        showALUForwarding(1);
    } else if (afMode == 1) {
        buttonAF.setCaption("ALU Interlock");
        showALUForwarding(0);
    } else if (afMode == 2) {
        buttonAF.setCaption("No ALU Interlock");
        showALUForwarding(0);
    }
    setArg("afMode", afMode.toString()); // {joj 6/11/16}
}

//
// setLIMode
//
function setSFMode(num mode) {
    sfMode = mode;
    if (sfMode == 0) {
        buttonSF.setCaption("Store Operand\nForwarding");
        showSMDRForwarding(1);
    } else if (sfMode == 1) {
        buttonSF.setCaption("Store Interlock");
        showSMDRForwarding(0);
    } else if (sfMode == 2) {
        buttonSF.setCaption("No Store Interlock");
        showSMDRForwarding(0);
    }
    setArg("sfMode", sfMode.toString()); // {joj 6/11/16}
}

//
// setZFMode
//
function setZFMode(num mode) {
    zfMode = mode;
    if (zfMode == 0) {
        buttonZF.setCaption("Zero Forwarding");
        showZeroForwarding(1);
    } else if (zfMode == 1) {
        buttonZF.setCaption("Zero Interlock");
        showZeroForwarding(0);
    } else if (zfMode == 2) {
        buttonZF.setCaption("No Zero Interlock");
        showZeroForwarding(0);
    }
    setArg("zfMode", zfMode.toString()); // {joj 6/11/16}
}

// initialisation

resetCircuit();

num i, v;
string s;

//
// clear instruction memory
//
for (i = 0; i < 32; i++)			// {joj 27/10/06}
    im.setOpcode(4*i, 0);			// {joj 27/10/06}

//
// initialise registers
//
for (i = 0; i < 4; i++) {                           // {joj 31/10/10}
    s = sprintf("r%d", i);							// {joj 2/10/16}
    regFile[i].setValue(getArgAsNum(s, 0));			// {joj 4/10/16}
}                                                   // {joj}

setTPS(20);                                         // {joj}
example = getArgAsNum("example", 0);				// {joj 4/10/16}

if (example == 0) {

    //
    // user defined
    //
    for (i = 0; i < 32; i++)  {                     // {joj}
        s = sprintf("i%d", i);						// {joj 31/10/10}
        im.setOpcode(4*i, getArgAsNum(s, 0));       // {joj 20/10/16}
    }

} else if (example == 1) {                          // {joj}

		im.setValue(0, ADDi, 12, 0, 4);
		im.setValue(4, ADDi, 13, 0, 5);
		im.setValue(8, ST, 12, 2, 0);
		im.setValue(12, SUBi, 2, 2, 4);
		im.setValue(16, JAL, 1, 0, 0x10);
		im.setValue(20, XOR, 0, 0, 0);
		im.setValue(0x18, HALT, 0, 0, 0);
		im.setValue(0x20, ST, 1, 2, 0);
		im.setValue(0x24, ADD, 8, 0, 2);
		im.setValue(0x28, SUBi, 2, 2, 4);
		im.setValue(0x2C, SUB, 10, 12, 13);
		im.setValue(0x30, SUBi, 2, 2, 4);
		im.setValue(0x34, SUBi, 2, 2, 4);
		im.setValue(0x38, JAL, 1, 0, 0x18);
		im.setValue(0x3C, LD, 1, 8, 0);
		im.setValue(0x40, ADDi, 2, 2, 12);
		im.setValue(0x44, JALR, 0, 0, 1);
		im.setValue(0x50, ST, 1, 2, 0);
		im.setValue(0x54, ADD, 9, 0, 2);
		im.setValue(0x58, SUBi, 2, 2, 4);
		im.setValue(0x5C, ST, 8, 2, 0);
		im.setValue(0x60, SUBi, 2, 2, 4);
		im.setValue(0x64, ADD, 8, 0, 9);
		im.setValue(0x68, LD, 1, 8, 0);
		im.setValue(0x6C, LD, 8, 8, -4);
		im.setValue(0x70, ADDi, 2, 2, 8);
		im.setValue(0x74, JALR, 0, 0, 1);
    //setTPS(100);                                    // {joj}

} else if (example == 2) {                          // {joj}

		//test parallel 1
		regFile[3].setValue(8);
		regFile[5].setValue(12);
		im.setValue(0, LR, 4, 0, 3);
		im.setValue(4, SC, 1, 5, 3);


} else if (example == 3) {                          // {joj}

		//test parallel 2
		regFile[3].setValue(8);
		regFile[5].setValue(6);
		im.setValue(0, LR, 4, 0, 3);
		im.setValue(4, NOP, 0, 0, 0);
		im.setValue(8, NOP, 0, 0, 0);
		im.setValue(12, NOP, 0, 0, 0);
		im.setValue(16, SC, 1, 5, 3);


} else if (example == 4) {

	//
    // branch prediction example
    //
    // im.setValue( 0, ADDi, 1, 0, 3);                 //      r1 = 3      // {joj}
    // im.setValue( 4, ADD,  0, 0, 0);                 // L:               // {joj}
    // im.setValue( 8, ADD,  0, 0, 0);                 //                  // {joj}
    // im.setValue(12, SUBi, 1, 1, 1);                 //      r1 = r1-1   // {joj}
    // im.setValue(16, BLT, 0, 1, -12 & 0xff);        //      bnez r1, L  // {joj}
    // im.setValue(20, HALT, 0, 0, 0);                 //                  // {joj}
    // setTPS(50);                                     // {joj}
		im.setValue(0, ADDi, 1, 0, 13);
		im.setValue(4, ADDi, 2, 0, 4);
		im.setValue(8, DIV, 3, 1, 2);

} else if (example == 5) {

	// used to fix reported errors

	// im.setValue( 0,   JR, 0, 0, 1);				// {joj 29/11/16}
	// im.setValue(32,  ADD, 1, 1, 1);				// {joj 29/11/16}
	// im.setValue(36, HALT, 0, 0, 0);				// {joj 29/11/16}
	// regFile[1].setValue(32);					// {joj 29/11/16}
	im.setValue(0, ADDi, 1, 0, 3);
	im.setValue(4, ADDi, 2, 0, 2);
	im.setValue(8, MUL, 3, 1, 2);

	//im.setValue( 0,  ADD, 2, 2, 3);				// {joj 30/11/16}
	//im.setValue( 4,  NOP, 0, 0, 0);				// {joj 30/11/16}
	//im.setValue( 8,  ADD, 1, 2, 3);				// {joj 30/11/16}
	//im.setValue(12, HALT, 0, 0, 0);				// {joj 30/11/16}

	//im.setValue( 0,   LD, 1, 0, 0);					// {joj 5/12/16}
	//im.setValue( 4, BEQZ, 0, 1, 28);				// {joj 5/12/16}
	//im.setValue(32, HALT, 0, 0, 0);					// {joj 5/12/16}

	//im.setValue( 0,   LD, 1, 0, 1);				// {joj 7/12/16}
	//im.setValue( 4,  ADD, 2, 0, 0);				// {joj 7/12/16}
	//im.setValue( 8,  ADD, 3, 0, 0);				// {joj 7/12/16}
	//im.setValue(12, BEQZ, 0, 1, 20);				// {joj 7/12/16}
	//im.setValue(32, HALT, 0, 0, 0);				// {joj 7/12/16}

}


//
// save args
//
if (example > 0) {										// {joj 27/10/06}

    for (i = 0; i < 32; i++) { 							// {joj 27/10/06}
        s = sprintf("i%d", i);							// {joj 31/10/10}
        setArg(s, im.getOpcode(i * 4).toString());		// {joj 6/11/16}
    }

    example = (example > maxexample) ? 0 : example		// {joj 28/11/16}

}

num haltOnHalt = getArgAsNum("haltOnHalt", 1);			// {joj 29/7/08}

bpMode = getArgAsNum("bpMode", 0); setBPMode(bpMode);	// {joj 27/11/16}
liMode = getArgAsNum("liMode", 0); setLIMode(liMode);	// {joj 27/11/16}
afMode = getArgAsNum("afMode", 0); setAFMode(afMode);	// {joj 27/11/16}
sfMode = getArgAsNum("sfMode", 0); setSFMode(sfMode);	// {joj 27/11/16}
zfMode = getArgAsNum("zfMode", 0); setZFMode(zfMode);	// {joj 27/11/16}
peMode = getArgAsNum("peMode", 0); setPEMode(peMode);	// {joj 27/11/16}
lockCircuit = getArgAsNum("locked", 0);					// {joj 27/11/16}

//
// Help
//
// num showHelp = getArgAsNum("help", 1);				// {joj 4/10/16}
//
// Rectangle r = Rectangle2(helpLayer, 0, 0, whiteBrush, 0, 0, WIDTH, HEIGHT);
// r.setOpacity(0.5);                                  // {joj 20/8/10}
// r.setRounded(10, 10);
//
// Pen helpPen = SolidPen(SOLID, 2, RED, ROUND_START | ROUND_JOIN | ROUND_END);
// Font helpFont = Font("Arial", 12, BOLD);
//
// Txt(helpLayer, HLEFT | VTOP, 12, 290, helpPen, helpFont, "LEFT CLICK on animation background to start and stop clock.\n\nSHIFT LEFT CLICK on background to execute \"single MIPS clock cycle\".");
// if (!lockCircuit) {
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 20, 68, 80, 10); r.setRounded(5, 5);
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 25, 121, 30, 10); r.setRounded(5, 5);
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 60, 121, 14, 10); r.setRounded(5, 5);
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 76, 121, 14, 10); r.setRounded(5, 5);
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 92, 121, 14, 10); r.setRounded(5, 5);
//     Txt(helpLayer, HLEFT | VTOP, 110, 60, helpPen, helpFont, "LEFT CLICK to change\ninitial program.");
//     Txt(helpLayer, HLEFT | VTOP, 110, 105, helpPen, helpFont, "LEFT or RIGHT CLICK to \"rotate\"\ninstructions and operands.\nHold and release to reset value.");
// }
//
// r = Rectangle2(helpLayer, 0, helpPen, 0, 310, 25, 90, 50);
// r.setRounded(10, 10);
// Txt(helpLayer, HLEFT | VTOP, 410, 40, helpPen, helpFont, "LEFT or RIGHT CLICK register\nto increment or decrement value.");
//
// if (!lockCircuit) {
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 110, 455, 550, 30);
//     r.setRounded(10, 10);
//     Txt(helpLayer, HLEFT | VTOP, 180, 435, helpPen, helpFont, "LEFT CLICK on any of the buttons below to change circuit configuration.");
// }
//
// Rectangle closeHelp = Rectangle2(helpLayer, 0, helpPen, yellowBrush, 305, 230, 100, 30, helpPen, helpFont, "CLOSE HELP");
// closeHelp.setRounded(5, 5);
//
// when closeHelp ~> eventEE(num enter, num x, num y) {			// {joj 24/9/17}
//     closeHelp.setBrush(enter ? gray224Brush : yellowBrush);		// {joj 17/10/16}
// }
//
// when closeHelp ~> eventMB(num down, num flags, num x, num y) {	// {joj 24/9/17}
// 	if (down && (flags & MB_LEFT)) {
// 		setArg("help", "0");   									// {joj 6/11/16}
// 		helpLayer.setOpacity(0);
// 	}
// 	return 0;
// }
//
// if (showHelp == 0)
//     helpLayer.setOpacity(0);

// eof
