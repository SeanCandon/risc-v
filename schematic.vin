//
// schematic.vin
//
// Simulation of the DLX
// Written by Edsko de Vries, Summer 2003
//
// Copyright (C) 2003 - 2018 Edsko de Vries and jones@scss.tcd.ie
//
// This program is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation;
// either version 2 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software Foundation Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
//

string name = getArg("name", "");					// optional name of code example {joj 2/11/16}
if (name != "")
	name = sprintf(":  %s", name);					// {joj 2/10/16}}

Font fTitle = Font("Calibri", 20, SMALLCAPS | ITALIC);

Rectangle title = Rectangle2(0, HLEFT, 0, SolidBrush(DARK_BLUE), -80, 10, 200, 30, whitePen, fTitle, sprintf(" RISC-V ANIMATION %s", name));	// {joj 2/10/16}

Pen borderPen = SolidPen(DASH, 1, DARK_BLUE, ROUND_START | ROUND_JOIN | ROUND_END);

Line2(0, ABSOLUTE, borderPen, 30, 80, 660, 80);
Line2(0, ABSOLUTE, borderPen, 30, 440, 660, 440);

Line2(0, ABSOLUTE, borderPen, 30, 80, 30, 440);
Line b1 = Line2(0, ABSOLUTE, borderPen, 160, 80, 160, 440);
Line b2 = Line2(0, ABSOLUTE, borderPen, 310, 80, 310, 440);
Line b3 = Line2(0, ABSOLUTE, borderPen, 510, 80, 510, 440);
Line b4 = Line2(0, ABSOLUTE, borderPen, 610, 80, 610, 440);
Line2(0, ABSOLUTE, borderPen, 660, 80, 660, 440);

// Buttons

const num BUTTON_PE = 0;    // Pipeling enabled
const num BUTTON_BP = 1;    // Branch prediction
const num BUTTON_LI = 2;    // Load numerlock
const num BUTTON_AF = 3;    // ALU forwarding
const num BUTTON_SF = 4;    // SMDR forwarding
const num BUTTON_ZF = 5;    // Zero forwarding

const num BUTTON_SP = 6;    // Safe program

const num NUM_REGS = 32;
const num REG_WIDTH = 20;
const num REG_HEIGHT = 25;

Pen delimeter = SolidPen(DOT, THIN, BLACK);
Line2(0, ABSOLUTE, delimeter, 10, 450, 700, 450);

Font arialBold10 = Font("Calibri", 10, BOLD);

Button buttonSP = Button(20, 460, 80, 20, "Save Configuration", BUTTON_SP);            // {joj}
Button buttonPE = Button(120, 460, 80, 20, "Pipelining Enabled", BUTTON_PE);           // {joj}
Button buttonBP = Button(210, 460, 80, 20, "Branch Prediction", BUTTON_BP);            // {joj}
Button buttonLI = Button(300, 460, 80, 20, "Load Interlock", BUTTON_LI);               // {joj}
Button buttonAF = Button(390, 460, 80, 20, "ALU Forwarding", BUTTON_AF);               // {joj}
Button buttonSF = Button(480, 460, 80, 20, "Store Operand\nForwarding", BUTTON_SF);    // {joj}
Button buttonZF = Button(570, 460, 80, 20, "Zero Forwarding", BUTTON_ZF);              // {joj}

//
// Vivio logo
//
// TODO: {joj 2/10.16}
//
const num LOGOW = 20;																	// 64 x 64 image
const num LOGOH = 20;
Image logo = Image(0, 0, 0, "vivio.png", 660,460, 0,0, LOGOW,LOGOH);					// {joj 24/9/17}

// Statistics

Txt(0, HLEFT | VTOP, -80, 46, darkGrayPen, font, "instructions executed:");		// {joj 25/7/10}
Rectangle et = Txt(0, HLEFT | VTOP, -80, 56, darkGrayPen, font, "ticks:");		// {joj}

Rectangle statIC = Txt(0, HLEFT | VTOP, 0, 46, redPen, font, "0");				// {joj}
Rectangle statTE = Txt(0, HLEFT | VTOP, 0, 56, redPen, font, "0");				// {joj}

// Instruction memory and clock
Rectangle imLabel = Rectangle2(0, 0, 0, 0, -80, 68, 100, 10, 0, font, "Instruction Cache"); // {joj}
InstructionMemory im = InstructionMemory(-80, 80, 100, 320);
AnimatedClock animClock = AnimatedClock(-70, 410, 80, 30);

// IF and PC
Register regPC = Register(120, 210, 20, 40, TOP, "PC");

// branch target buffer
Rectangle btbLabel  = Rectangle2(0, 0, 0, 0, 70, 85, 80, 10, 0, font, "Branch Target Buffer");    // {joj}
Register btbPC[2];										// {joj 2/10/16}
btbPC[0]  = Register(70, 100, 40, 20, LEFT, "PC");     // {joj 1/2/06}
btbPC[1]  = Register(70, 120, 40, 20, LEFT, "PC");     // {joj 1/2/06}
Register btbPPC[2];										// {joj 2/10/16}
btbPPC[0] = Register(110, 100, 40, 20, RIGHT, "PPC");   // {joj 1/2/06}
btbPPC[1] = Register(110, 120, 40, 20, RIGHT, "PPC");   // {joj 1/2/06}

// Other components
Component cMUX2 = Component(120, 170, 30, 10, "mux 2");       // {joj}
Component cMUX1 = Component(90, 205, 10, 50, "mux 1");       // {joj}
Component cPLUS4 = Component(80, 270, 20, 10, "+4");

// connections from and to instruction memory
AnimPipe apIM_ID = AnimPipe();
apIM_ID.addPoint(30, 390);
apIM_ID.addPoint(170, 390);
Rectangle txtIM_ID = Rectangle(activePipesLayer, 0, 0, redBrush, 180,390, -30,-6, 60,12, whitePen, font);	// {joj 1/4/06, 17/10/16}
txtIM_ID.setRounded(2, 2);	// {joj 17/10/16}

AnimPipe apPC_IM = AnimPipe();
apPC_IM.addPoint(130, 250);
apPC_IM.addPoint(130, 320);
apPC_IM.addPoint(30, 320);

// connections into MUX1
AnimPipe apMUX3_MUX1 = AnimPipe();
apMUX3_MUX1.addPoint(220, 170);
apMUX3_MUX1.addPoint(220, 160);
apMUX3_MUX1.addPoint(70, 160);
apMUX3_MUX1.addPoint(70, 215);
apMUX3_MUX1.addPoint(90, 215);

AnimPipe apBTB_MUX1 = AnimPipe();
apBTB_MUX1.addPoint(70, 120);
apBTB_MUX1.addPoint(60, 120);
apBTB_MUX1.addPoint(60, 225);
apBTB_MUX1.addPoint(90, 225);

AnimPipe apRF_MUX1 = AnimPipe();
//apRF_MUX1.addPoint(315, 50);
apRF_MUX1.addPoint(160, 50);
apRF_MUX1.addPoint(50, 50);
apRF_MUX1.addPoint(50, 235);
apRF_MUX1.addPoint(90, 235);

AnimPipe apADD4_MUX1 = AnimPipe();
apADD4_MUX1.addPoint(80, 275);
apADD4_MUX1.addPoint(40, 275);
apADD4_MUX1.addPoint(40, 245);
apADD4_MUX1.addPoint(90, 245);

// Connections to and from PC
AnimPipe apMUX1_PC = AnimPipe();
apMUX1_PC.addPoint(100, 230);
apMUX1_PC.addPoint(120, 230);

AnimPipe apPC_MUX2 = AnimPipe();
apPC_MUX2.addPoint(130, 210);
apPC_MUX2.addPoint(130, 180);

AnimPipe apPC_ADD4 = AnimPipe();
apPC_ADD4.addPoint(130, 250);
apPC_ADD4.addPoint(130, 275);
apPC_ADD4.addPoint(100, 275);

AnimPipe apPC_PC1 = AnimPipe();
apPC_PC1.addPoint(140, 230);
apPC_PC1.addPoint(160, 230);
apPC_PC1.addPoint(160, 230);

// MUX2 to BTB
AnimPipe apMUX2_BTB = AnimPipe();
apMUX2_BTB.addPoint(135, 170);
apMUX2_BTB.addPoint(135, 140);

//
// Instruction Decode
//
// ID to EX
//
AnimPipe apID_EX = AnimPipe();
apID_EX.addPoint(190, 390);
apID_EX.addPoint(310, 390);

// ID and PC1
InstructionRegister regID = InstructionRegister(170, 350, 20, 85, "ID");
Register regPC1 = Register(170, 210, 20, 40, TOP, "PC1");

// Register file
Txt(0, HLEFT | VTOP, 400, 40, 0, font, "Register\nFile");		// {joj}
// Register regFile[4];
// regFile[0] = Register(315, 30, 20, 30, TOP, "R0"); regFile[0].setFixed();                  // {joj 29/10/06}
// regFile[1] = Register(315, 50, 20, 30, TOP, "R1");
// regFile[2] = Register(355, 30, 20, 30, TOP, "R2");
// regFile[3] = Register(355, 50, 20, 30, TOP, "R3");

Register regFile[NUM_REGS];
num xpos = 160;
num ypos = 25;
num pos = TOP;
for (i=0; i<NUM_REGS; i++){
	if (i == (NUM_REGS/2)) {
		pos = BOTTOM;
		xpos = 160;
		ypos += REG_HEIGHT;
	}
	string str = "x" + i.toString();
	regFile[i] = Register(xpos, ypos, REG_WIDTH, REG_HEIGHT, pos, str);
	xpos += REG_WIDTH;
}

// Other components
Component cMUX3 = Component(195, 170, 50, 10, "mux 3");                                               // {joj}
Component cADD4 = Component(190, 320, 30, 10, "ADD4");                                                // {joj}
Component cADDi = Component(220, 320, 30, 10, "ADDi");                                                //
Component cMUX4 = Component(170, 100, 10, 40, "mux 4");                                               // {joj}
Component cMUX5 = Component(295, 220, 10, 30, "mux 5");                                               // {joj}

Rectangle2(0, 0, 0, 0, 200, 365, 20, 10, 0, font, "4");

// Control lines for MUX3
Pen controlPen = SolidPen(SOLID, 0, PURPLE, ARROW60_END);
Pen controlHLPen = SolidPen(SOLID, 2, RED, ARROW60_END);
Pen muxPen = SolidPen(SOLID, MEDIUM, BLACK);															// {joj}

// inputs to cZeroMux
//Line clALU = Line2(valuesLayer, ABSOLUTE, controlPen, 548,230, 548,150, 335,150, 335,160);		// {joj 8/12/16}
//Line clOUT0 = Line2(valuesLayer, ABSOLUTE, controlPen, 646,230, 646,145, 330,145, 330,160);		// {joj 8/12/16}
//Line clOUT1 = Line2(valuesLayer, ABSOLUTE, controlPen, 690,140, 325,140, 325,160);				// {joj 8/12/16}
//Line clA = Line(valuesLayer, ABSOLUTE, controlPen, 0,0, 340,135, 315,135, 315,160);
//Line clMUX = Line2(valuesLayer, ABSOLUTE, controlPen, 325,160, 325,175, 295,175);

//Line cZeroMux = Line2(valuesLayer, ABSOLUTE, muxPen, 314, 160, 336, 160);
//Rectangle cZeroTxt = Txt(valuesLayer,HLEFT | VTOP, 316, 162, 0, font, "zero");			// {joj}

// Line clDM1 = Line2(valuesLayer, ABSOLUTE, controlPen, 320, 390,
// 	320, 305,
// 	308, 305
// 	);

//zero input to alu for comparison during multiply operation
Line cZero = Line2(valuesLayer, ABSOLUTE, muxPen, 460, 100, 480, 100);
Rectangle cZeroTxt = Txt(valuesLayer,HLEFT | VTOP, 462, 90, 0, font, "zero");
Line clALU1 = Line2(valuesLayer, ABSOLUTE, controlPen, 470, 102, 470, 200);

Line clZeroA = Line2(valuesLayer, ABSOLUTE, controlPen,
	470, 102,
	470, 140,
	325, 140,
	325, 220,
	340, 220
);

//output of ALU which determines whether branch should be taken
Line clALU2 = Line2(valuesLayer, ABSOLUTE, controlPen, 490, 220,
	500, 220,
	500, 150,
	305, 150,
	305, 175,
	245, 175
	);

// Connections from PC1
AnimPipe apPC1_MUX2 = AnimPipe();
apPC1_MUX2.addPoint(180, 210);
apPC1_MUX2.addPoint(180, 200);
apPC1_MUX2.addPoint(140, 200);
apPC1_MUX2.addPoint(140, 180);

AnimPipe apADD4_MUX5 = AnimPipe();
apADD4_MUX5.addPoint(205, 320);
apADD4_MUX5.addPoint(205, 240);
apADD4_MUX5.addPoint(295, 240);

AnimPipe apPC1_ADD4 = AnimPipe();
apPC1_ADD4.addPoint(180, 250);
apPC1_ADD4.addPoint(180, 345);
apPC1_ADD4.addPoint(210, 345);
apPC1_ADD4.addPoint(210, 330);

AnimPipe apPC1_ADDi = AnimPipe();
apPC1_ADDi.addPoint(180, 250);
apPC1_ADDi.addPoint(180, 345);
apPC1_ADDi.addPoint(230, 346);
apPC1_ADDi.addPoint(230, 330);

// Connections to and from the adders
AnimPipe ap4_ADD4 = AnimPipe();
ap4_ADD4.addPoint(210, 360);
ap4_ADD4.addPoint(210, 330);

AnimPipe apID_ADDi = AnimPipe();
apID_ADDi.addPoint(190, 390);
apID_ADDi.addPoint(240, 390);
apID_ADDi.addPoint(240, 330);
Rectangle txtID_ADDi = Rectangle(activePipesLayer, 0, 0, redBrush, 320,376, -12,-6, 24,12, whitePen, font);		// {joj 29/10/06, 17/10/16}
txtID_ADDi.setRounded(2, 2);	// {joj 17/10/16}

AnimPipe apADD4_MUX3 = AnimPipe();
apADD4_MUX3.addPoint(205, 320);
apADD4_MUX3.addPoint(205, 180);

Rectangle txtADD4_MUX3 = Rectangle(activePipesLayer, 0, 0, redBrush, 285,200, -12,-6, 24,12, whitePen, font);	// {joj 29/10/06, 15/3/15}
txtADD4_MUX3.setRounded(2, 2); // {joj 17/10/16}

AnimPipe apADDi_DM1 = AnimPipe();
apADDi_DM1.addPoint(235, 320);
apADDi_DM1.addPoint(235, 310);

AnimPipe apDM1_MUX3 = AnimPipe();
apDM1_MUX3.addPoint(227, 300);
apDM1_MUX3.addPoint(227, 180);
Rectangle txtDM1_MUX3 = Rectangle(activePipesLayer, 0, 0, redBrush, 315,200, -12,-6, 24,12, whitePen, font);	// {joj 29/10/06, 15/3/15}
txtDM1_MUX3.setRounded(2, 2);

AnimPipe apDM1_MUX5 = AnimPipe();
apDM1_MUX5.addPoint(227, 300);
apDM1_MUX5.addPoint(227, 240);
apDM1_MUX5.addPoint(295, 240);

AnimPipe apDM1_REGM = AnimPipe();
apDM1_REGM.addPoint(235, 300);
apDM1_REGM.addPoint(235, 280);
apDM1_REGM.addPoint(265, 280);

AnimPipe apREGM_MUX3 = AnimPipe();
apREGM_MUX3.addPoint(280, 270);
apREGM_MUX3.addPoint(280, 255);
apREGM_MUX3.addPoint(237, 255);
apREGM_MUX3.addPoint(237, 180);

Component cDEMUX1 = Component(217, 300, 40, 10, "demux 1");
Register maybeR = Register(265, 270, 30, 20, LEFT, "M");
maybeR.rotateLabel(90);                                           // {joj}

// Connection to BTB
AnimPipe apMUX3_MUX4 = AnimPipe();
apMUX3_MUX4.addPoint(220, 170);
apMUX3_MUX4.addPoint(220, 130);
apMUX3_MUX4.addPoint(180, 130);
Rectangle txtMUX3_MUX4 = Rectangle(activePipesLayer, 0, 0, redBrush, 300,160, -12,-6, 24,12, whitePen, font);	// {joj 29/10/06, 15/3/15}
txtMUX3_MUX4.setRounded(2, 2); // {joj 17/10/16}

AnimPipe apMUX4_BTB = AnimPipe();
apMUX4_BTB.addPoint(170, 120);
apMUX4_BTB.addPoint(150, 120);

AnimPipe apRF_MUX4 = AnimPipe();
apRF_MUX4.addPoint(160, 60);
apRF_MUX4.addPoint(140, 60);
apRF_MUX4.addPoint(140, 83);
apRF_MUX4.addPoint(200, 83);
apRF_MUX4.addPoint(200, 110);
apRF_MUX4.addPoint(180, 110);
Rectangle txtRF_MUX1 = Rectangle(activePipesLayer, 0, 0, redBrush, 300,44, -12,0, 24,12, whitePen, font);   // {joj 4/11/12}

// MUX5 to A
AnimPipe apMUX5_B = AnimPipe();
apMUX5_B.addPoint(305, 240);
apMUX5_B.addPoint(340, 240);

// Connections from the register file
AnimPipe apRF_MUX5 = AnimPipe();
apRF_MUX5.addPoint(280, 75);
apRF_MUX5.addPoint(280, 230);
apRF_MUX5.addPoint(295, 230);
Rectangle txtRF_MUX5 = Rectangle(activePipesLayer, 0, 0, redBrush, 340,82, -12,0, 24,12, whitePen, font, "R0:0");   // {joj 1/4/06, 17/10/16}
txtRF_MUX5.setRounded(2, 2);	// {joj 17/10/16}

AnimPipe apRF_A = AnimPipe();
apRF_A.addPoint(295, 75);
apRF_A.addPoint(295, 210);
apRF_A.addPoint(340, 210);
Rectangle txtRF_A = Rectangle(activePipesLayer, 0, 0, redBrush, 370,82, -12,0, 24,12, whitePen, font, "R0:0");      // {joj 1/4/06, 17/10/16}
txtRF_A.setRounded(2, 2);	// {joj 17/10/16}

//
// Execution
//
// EX, A and B
//
InstructionRegister regEX = InstructionRegister(310, 350, 20, 85, "EX");
Register regA = Register(340, 190, 20, 40, TOP, "A");
Register regB = Register(340, 230, 20, 40, BOTTOM, "B");

// Component cDECR = Component(328, 290, 23, 10, "SUB");
// Component cINCR = Component(337, 120, 23, 10, "ADD");

// AnimPipe apB_SUB1 = AnimPipe();
// apB_SUB1.addPoint(340, 260);
// apB_SUB1.addPoint(315, 260);
// apB_SUB1.addPoint(315, 295);
// apB_SUB1.addPoint(328, 295);
//
// AnimPipe apA_ADD1 = AnimPipe();
// apA_ADD1.addPoint(340, 200);
// apA_ADD1.addPoint(315, 200);
// apA_ADD1.addPoint(315, 125);
// apA_ADD1.addPoint(337, 125);

// Rectangle2(0, 0, 0, 0, 320, 315, 20, 10, 0, font, "-1");
// Rectangle2(0, 0, 0, 0, 320, 95, 20, 10, 0, font, "+1");

// AnimPipe ap1_SUB1 = AnimPipe();
// ap1_SUB1.addPoint(338, 320);
// ap1_SUB1.addPoint(345, 320);
// ap1_SUB1.addPoint(345, 300);
//
// AnimPipe ap1_ADD1 = AnimPipe();
// ap1_ADD1.addPoint(338, 100);
// ap1_ADD1.addPoint(345, 100);
// ap1_ADD1.addPoint(345, 120);
//
// AnimPipe apSUB1_B = AnimPipe();
// apSUB1_B.addPoint(345, 290);
// apSUB1_B.addPoint(345, 270);
//
// AnimPipe apADD1_A = AnimPipe();
// apADD1_A.addPoint(345, 130);
// apADD1_A.addPoint(345, 190);

// Other components
Component cMUX6 = Component(420, 180, 10, 50, "mux 6");   // {joj}
Component cMUX7 = Component(420, 230, 10, 50, "mux 7");   // {joj}
Component cMUX8 = Component(420, 310, 10, 40, "mux 8");   // {joj}
ALU alu = ALU(450, 190, 40, 80);

// EX to MA
AnimPipe apEX_MA = AnimPipe();
apEX_MA.addPoint(330, 390);
apEX_MA.addPoint(530, 390);

// Connections numo MUX6
AnimPipe apOUT0_MUX6 = AnimPipe();
apOUT0_MUX6.addPoint(530, 210);
apOUT0_MUX6.addPoint(530, 170);
apOUT0_MUX6.addPoint(390, 170);
apOUT0_MUX6.addPoint(390, 190);
apOUT0_MUX6.addPoint(420, 190);

// AnimPipe apOUT0_A = AnimPipe();
// apOUT0_A.addPoint(530, 210);
// apOUT0_A.addPoint(530, 170);
// apOUT0_A.addPoint(355, 170);
// apOUT0_A.addPoint(355, 190);

AnimPipe apOUT1_MUX6 = AnimPipe();
apOUT1_MUX6.addPoint(630, 210);
apOUT1_MUX6.addPoint(630, 160);
apOUT1_MUX6.addPoint(380, 160);
apOUT1_MUX6.addPoint(380, 200);
apOUT1_MUX6.addPoint(420, 200);

// AnimPipe apOUT1_A = AnimPipe();
// apOUT1_A.addPoint(630, 210);
// apOUT1_A.addPoint(630, 160);
// apOUT1_A.addPoint(355, 160);
// apOUT1_A.addPoint(355, 190);

AnimPipe apA_MUX6 = AnimPipe();
apA_MUX6.addPoint(360, 220);
apA_MUX6.addPoint(420, 220);

// Connections numo MUX7
AnimPipe apB_MUX7 = AnimPipe();
apB_MUX7.addPoint(360, 240);
apB_MUX7.addPoint(420, 240);

AnimPipe apEX_MUX7 = AnimPipe();
apEX_MUX7.addPoint(330, 390);
apEX_MUX7.addPoint(370, 390);
apEX_MUX7.addPoint(370, 250);
apEX_MUX7.addPoint(420, 250);
Rectangle txtEX_MUX7 = Rectangle(activePipesLayer, 0, 0, redBrush, 432,370, -10,0, 20,12, whitePen, font, "IMM");	// {joj 1/4/06, 17/10/16}
txtEX_MUX7.setRounded(2, 2);	// {joj 17/10/16}

AnimPipe apOUT1_MUX7 = AnimPipe();
apOUT1_MUX7.addPoint(630, 250);
apOUT1_MUX7.addPoint(630, 300);
apOUT1_MUX7.addPoint(380, 300);
apOUT1_MUX7.addPoint(380, 260);
apOUT1_MUX7.addPoint(420, 260);

// AnimPipe apOUT1_B = AnimPipe();
// apOUT1_B.addPoint(630, 250);
// apOUT1_B.addPoint(630, 300);
// apOUT1_B.addPoint(355, 300);
// apOUT1_B.addPoint(355, 270);

AnimPipe apOUT0_MUX7 = AnimPipe();
apOUT0_MUX7.addPoint(530, 250);
apOUT0_MUX7.addPoint(530, 290);
apOUT0_MUX7.addPoint(390, 290);
apOUT0_MUX7.addPoint(390, 270);
apOUT0_MUX7.addPoint(420, 270);

// AnimPipe apOUT0_B = AnimPipe();
// apOUT0_B.addPoint(530, 250);
// apOUT0_B.addPoint(530, 290);
// apOUT0_B.addPoint(355, 290);
// apOUT0_B.addPoint(355, 270);

// Connectings to and from MUX8
AnimPipe apOUT0_MUX8 = AnimPipe();
apOUT0_MUX8.addPoint(530, 250);
apOUT0_MUX8.addPoint(530, 290);
apOUT0_MUX8.addPoint(390, 290);
apOUT0_MUX8.addPoint(390, 320);
apOUT0_MUX8.addPoint(420, 320);

AnimPipe apOUT1_MUX8 = AnimPipe();
apOUT1_MUX8.addPoint(630, 250);
apOUT1_MUX8.addPoint(630, 300);
apOUT1_MUX8.addPoint(380, 300);
apOUT1_MUX8.addPoint(380, 330);
apOUT1_MUX8.addPoint(420, 330);

AnimPipe apB_MUX8 = AnimPipe();
apB_MUX8.addPoint(355, 270);
apB_MUX8.addPoint(355, 340);
apB_MUX8.addPoint(420, 340);

AnimPipe apMUX8_SMDR = AnimPipe();
apMUX8_SMDR.addPoint(430, 330);
apMUX8_SMDR.addPoint(520, 330);

//
// Connections from MUX6 through the ALU to OUT0
//
AnimPipe apMUX6_ALU = AnimPipe();
apMUX6_ALU.addPoint(430, 205);
apMUX6_ALU.addPoint(450, 205);
// apMUX6_ALU.addPoint(510, 230);
// apMUX6_ALU.addPoint(560, 230);

AnimPipe apMUX7_ALU = AnimPipe();
apMUX7_ALU.addPoint(430, 255);
apMUX7_ALU.addPoint(450, 255);
// apMUX7_ALU.addPoint(510, 230);
// apMUX7_ALU.addPoint(560, 230);

AnimPipe apALU_OUT0 = AnimPipe();
apALU_OUT0.addPoint(490, 240);
apALU_OUT0.addPoint(520, 240);

//
// Memory access
//
// MA, SMDR and OUT0
//
InstructionRegister regMA = InstructionRegister(530, 350, 20, 85, "MA");
Register regOUT0 = Register(520, 210, 20, 40, TOP, "O0");
Register regSMDR = Register(520, 320, 40, 20, RIGHT, "SMR");
Txt(valuesLayer, HLEFT | VTOP, 553, 100, 0, font, "memory\naddress");        // {joj}
Txt(valuesLayer, HLEFT | VTOP, 605, 320, 0, font, "memory\ndata-in");        // {joj}
Txt(valuesLayer, HLEFT | VTOP, 615, 100, 0, font, "memory\ndata-out");       // {joj}

// Memory
Txt(0, HLEFT | VTOP, 645, 35, 0, font, "Data\nCache\n(memory)"); // {joj}
Register memory[4];
memory[0] = Register(560, 30, 40, 20, LEFT, "M0");
memory[1] = Register(560, 50, 40, 20, LEFT, "M1");
memory[2] = Register(600, 30, 40, 20, RIGHT, "M2");
memory[3] = Register(600, 50, 40, 20, RIGHT, "M3");

// Stack
Stack stack = Stack(680, 60);
//stack.setFP(10);
//stack.createFrame(2, 1);

//
// Other components
//
Component cMUX9 = Component(590, 210, 10, 40, "mux 9");                                                   // {joj}

// MA to WB
AnimPipe apMA_WB = AnimPipe();
apMA_WB.addPoint(550, 390);
apMA_WB.addPoint(620, 390);

// OUT0 to MUX 8/OUT1
//
AnimPipe apOUT0_MUX9 = AnimPipe();
apOUT0_MUX9.addPoint(540, 230);
apOUT0_MUX9.addPoint(590, 230);

AnimPipe apMUX9_OUT1 = AnimPipe();
apMUX9_OUT1.addPoint(600, 230);
apMUX9_OUT1.addPoint(620, 230);

// Connections to and from memory

// AnimPipe apOUT0_Mem = AnimPipe();
// apOUT0_Mem.addPoint(580, 230);
// apOUT0_Mem.addPoint(590, 230);
// apOUT0_Mem.addPoint(590, 70);
//
// AnimPipe apSMDR_Mem = AnimPipe();
// apSMDR_Mem.addPoint(590, 330);
// apSMDR_Mem.addPoint(600, 330);
// apSMDR_Mem.addPoint(600, 70);
//
// AnimPipe apMem_MUX9 = AnimPipe();
// apMem_MUX9.addPoint(610, 70);
// apMem_MUX9.addPoint(610, 220);
// apMem_MUX9.addPoint(630, 220);

AnimPipe apOUT0_Mem = AnimPipe();
apOUT0_Mem.addPoint(540, 230);
apOUT0_Mem.addPoint(550, 230);
apOUT0_Mem.addPoint(550, 110);
apOUT0_Mem.addPoint(680, 110);

AnimPipe apSMDR_Mem = AnimPipe();
apSMDR_Mem.addPoint(560, 330);
apSMDR_Mem.addPoint(680, 330);

AnimPipe apMem_MUX9 = AnimPipe();
apMem_MUX9.addPoint(680, 90);
apMem_MUX9.addPoint(570, 90);
apMem_MUX9.addPoint(570, 220);
apMem_MUX9.addPoint(590, 220);

//
// Write Back
//

// WB and OUT1

InstructionRegister regWB = InstructionRegister(620, 350, 20, 85, "WB");
Register regOUT1 = Register(620, 210, 20, 40, TOP, "O1");

// Connections from OUT1 to the register file

AnimPipe apOUT1_RF = AnimPipe();
apOUT1_RF.addPoint(640, 230);
apOUT1_RF.addPoint(650, 230);
apOUT1_RF.addPoint(650, 10);
apOUT1_RF.addPoint(390, 10);
apOUT1_RF.addPoint(390, 25);

alu.txtResult.moveToFront();                            // {joj 29/10/06}

//
// ResetWires
//
function resetWires() {

	//
	// IF
	//
    apPC_IM.reset();
    apIM_ID.reset();
    txtIM_ID.setOpacity(0);                             // {joj 29/10/06}
    //apIF_ID.reset();
    apMUX3_MUX1.reset();
    apBTB_MUX1.reset();
    apRF_MUX1.reset();
    apADD4_MUX1.reset();
    apMUX1_PC.reset();
    apPC_MUX2.reset();
    apPC_ADD4.reset();
    apPC_PC1.reset();
    apMUX2_BTB.reset();

    //
	// ID
	//
    apID_EX.reset();
    apPC1_MUX2.reset();
    //apPC1_MUX5.reset();
    apADD4_MUX5.reset();
    apPC1_ADD4.reset();
    apPC1_ADDi.reset();
    ap4_ADD4.reset();
    apID_ADDi.reset(); txtID_ADDi.setOpacity(0);            // {joj 29/10/06}
    apADD4_MUX3.reset(); txtADD4_MUX3.setOpacity(0);        // {joj 29/10/06}
    apDM1_MUX3.reset(); txtDM1_MUX3.setOpacity(0);
		apDM1_MUX5.reset();
		apDM1_REGM.reset();     // {joj 29/10/06}
		apADDi_DM1.reset();
    apMUX3_MUX4.reset(); txtMUX3_MUX4.setOpacity(0);        // {joj 29/10/06}
    apRF_MUX4.reset();
    apMUX4_BTB.reset();
    apMUX5_B.reset();
    apRF_MUX5.reset(); txtRF_MUX5.setOpacity(0);            // {joj}
    apRF_A.reset(); txtRF_A.setOpacity(0);                  // {joj}
    txtRF_MUX1.setOpacity(0);								// {joj 4/11/12}
	//clALU.setPen(controlPen);
    //clOUT0.setPen(controlPen);
    //clOUT1.setPen(controlPen);
    //clA.setPen(controlPen);
    //clMUX.setPen(controlPen);

		clALU1.setPen(controlPen);
		clZeroA.setPen(controlPen);
		clALU2.setPen(controlPen);
		//clDM1.setPen(controlPen);

    //
    // EX
    //
    apEX_MA.reset();
    apOUT0_MUX6.reset();
    apOUT1_MUX6.reset();
		//apOUT0_A.reset();
		//apOUT1_A.reset();
    apA_MUX6.reset();
    apB_MUX7.reset();
    apEX_MUX7.reset(); txtEX_MUX7.setOpacity(0);        // {joj 29/10/06}
    apOUT1_MUX7.reset();
    apOUT0_MUX7.reset();
    apOUT0_MUX8.reset();
    apOUT1_MUX8.reset();
    apB_MUX8.reset();
		//apB_SUB1.reset();
		//ap1_SUB1.reset();
		//apSUB1_B.reset();
		//apA_ADD1.reset();
		//ap1_ADD1.reset();
		//apADD1_A.reset();
    apMUX8_SMDR.reset();
    apMUX6_ALU.reset();
    apMUX7_ALU.reset();
		apALU_OUT0.reset();
		//apOUT1_B.reset();
		//apOUT0_B.reset();
    alu.txtOp.setOpacity(0);                            // hide ALU txtOp {joj 29/10/06}
    alu.txtResult.setOpacity(0);                        // hide ALU txtResult {joj 29/10/06}

		clALU1.setPen(controlPen);
		clZeroA.setPen(controlPen);
    //
    // MA
    //
    apMA_WB.reset();
    apOUT0_MUX9.reset();
    apMUX9_OUT1.reset();
    apOUT0_Mem.reset();
    apSMDR_Mem.reset();
    apMem_MUX9.reset();

    //
    // WB
    //
    apOUT1_RF.reset();

}

//
// resetRegisters()
//
function resetRegisters() {

    regPC.reset(); regPC.setValue(0x7C);
    regPC1.reset();
    regA.reset();
    regB.reset();
    regSMDR.reset();
    regOUT0.reset();
    regOUT1.reset();

    btbPC[0].reset();               // {joj 1/2/06}
    btbPC[1].reset();               // {joj 1/2/06}
    btbPPC[0].reset();              // {joj 1/2/06}
    btbPPC[1].reset();              // {joj 1/2/06}

//  regFile[0].reset();
//  regFile[1].reset();
//  regFile[2].reset();
//  regFile[3].reset();

//  memory[0].reset();
//  memory[1].reset();
//  memory[2].reset();
//  memory[3].reset();

    regID.reset();
    regEX.reset();
    regMA.reset();
    regWB.reset();

    im.setActive(0x7C);

    regOUT0.setInvalid(1);
    regOUT0.updateLabel();
    regOUT1.setInvalid(1);
    regOUT1.updateLabel();
    btbPC[0].setValue(-1);          // {joj 1/2/06} - was (-1) & 0xFF
    btbPC[0].setInvalid(1);         // {joj 1/2/06}
    btbPC[0].updateLabel();         // {joj 1/2/06}
    btbPC[1].setValue(-1);          // {joj 1/2/06} - was (-1) & 0xFF
    btbPC[1].setInvalid(1);         // {joj 1/2/06}
    btbPC[1].updateLabel();         // {joj 1/2/06}

    instrCount = 0;
    tickCount = 0;

    statIC.setTxt("%4d", 0);        // {joj}
    statTE.setTxt("%4d", 0);        // {joj}

}

function resetCircuit() {
    resetRegisters();
    resetWires();
}

//
// Enabling and disabling parts of the pipeline
//
function showBTB(num opacity) {

    btbLabel.setOpacity(opacity);
    btbPC[0].setOpacity(opacity);   // {joj 1/2/06}
    btbPC[1].setOpacity(opacity);   // {joj 1/2/06}
    btbPPC[0].setOpacity(opacity);  // {joj 1/2/06}
    btbPPC[1].setOpacity(opacity);  // {joj 1/2/06}

    apPC_MUX2.setOpacity(opacity);
    apPC1_MUX2.setOpacity(opacity);
    cMUX2.setOpacity(opacity);
    apMUX2_BTB.setOpacity(opacity);

    apBTB_MUX1.setOpacity(opacity);

    apMUX3_MUX4.setOpacity(opacity);
    apRF_MUX4.setOpacity(opacity);
    cMUX4.setOpacity(opacity);
    apMUX4_BTB.setOpacity(opacity);

}

//
// showALUForwarding
//
function showALUForwarding(num opacity) {  // {joj 20/8/10}

    if (opacity == 0) {

        //
        // NOT pipelined
        //
        apA_MUX6.setPoint(0, 360, 205);
        apA_MUX6.setPoint(1, 421, 205);

        apB_MUX7.setPoint(0, (afMode) ? 360 : 350, 250);    // {joj 28/10/06}
        apB_MUX7.setPoint(1, 410, 250);

        apEX_MUX7.setPoint(2, 370, 260);
        apEX_MUX7.setPoint(3, 410, 260);

        apA_MUX6.setHead(0);

    } else {

        apA_MUX6.setPoint(0, 360, 220);
        apA_MUX6.setPoint(1, 420, 220);

        apB_MUX7.setPoint(0, 360, 240);
        apB_MUX7.setPoint(1, 420, 240);

        apEX_MUX7.setPoint(2, 370, 250);
        apEX_MUX7.setPoint(3, 420, 250);

        apA_MUX6.setHead(1);

    }

    cMUX6.setOpacity(opacity);
    apOUT0_MUX6.setOpacity(opacity);
    apOUT1_MUX6.setOpacity(opacity);

    apOUT0_MUX7.setOpacity(opacity);
    apOUT1_MUX7.setOpacity(opacity);

}

//
// showSMDRForwarding
//
function showSMDRForwarding(num opacity) { // {joj 20/8/10}

    if (opacity == 0) {

        apB_MUX8.setPoint(1, 355, 330);
        apB_MUX8.setPoint(2, 420, 330);
        apB_MUX8.setHead(0);

    } else {

        apB_MUX8.setPoint(1, 355, 340);
        apB_MUX8.setPoint(2, 420, 340);
        apB_MUX8.setHead(1);

    }

    cMUX8.setOpacity(opacity);
    apOUT0_MUX8.setOpacity(opacity);
    apOUT1_MUX8.setOpacity(opacity);

}

//
// showZeroForwarding
//
function showZeroForwarding(num opacity) { // {joj 20/8/10}

    if (opacity == 0) {
        //clA.setPt(1, -15, 0);				// {joj 15/3/15}
        //clA.setPt(2, -15, 25);			// {joj 15/3/15}
        //clA.setPt(1, 325, 135);				// {joj 5/10/16}
        //clA.setPt(2, 325, 160);				// {joj 5/10/16}
    } else {
		//clA.setPt(1, -25, 0);				// {joj 15/3/15}
        //clA.setPt(2, -25, 25);			// {joj 15/3/15}
		//clA.setPt(1, 315, 135);				// {joj 5/10/16}
        //clA.setPt(2, 315, 160);				// {joj 5/10/16}

   }

    //cZeroMux.setOpacity(opacity);
    //cZeroTxt.setOpacity(opacity);
    //clALU.setOpacity(opacity);
    //clOUT0.setOpacity(opacity);
    //clOUT1.setOpacity(opacity);

}

//
// showPipeline
//
function showPipeline(num opacity) {   // {joj 20/8/10}

    if (opacity == 0) {

        //
        // not pipelined
        //
        apPC_PC1.setPoint(1, 180, 230);
        apPC_PC1.setPoint(2, 180, 240);

        apPC1_ADD4.setPoint(0, 180, 230);
        apPC1_ADDi.setPoint(0, 180, 230);

        apID_EX.setPoint(1, 300, 390);

        apRF_A.setPoint(1, 295, 205);
        apRF_A.setPoint(2, 360, 205);
        apMUX5_B.setPoint(1, 360, 240);             // {joj 28/10/06}
        apB_MUX8.setPoint(0, 355, 250);

        //apMUX6_ALU.setPoint(3, 580, 230);
        //apMUX7_ALU.setPoint(3, 580, 230);
				apALU_OUT0.setPoint(3, 520, 240);

        apMUX8_SMDR.setPoint(1, 530, 330);
        apMUX9_OUT1.setPoint(1, 640, 230);

        apID_EX.setHead(0);
        apPC_PC1.setHead(0);
        apRF_A.setHead(0);
        apA_MUX6.setHead(0);
        apMUX5_B.setHead(0);
        apB_MUX8.setHead(0);
        apMUX8_SMDR.setHead(0);
        apMUX6_ALU.setHead(0);
        apMUX7_ALU.setHead(0);
				apALU_OUT0.setHead(0);
        apMUX9_OUT1.setHead(0);

        showBTB(opacity);
        showALUForwarding(opacity);
        showSMDRForwarding(opacity);
        showZeroForwarding(opacity);

    } else {

        apPC_PC1.setPoint(1, 160, 230);
        apPC_PC1.setPoint(2, 170, 230);

        apPC1_ADD4.setPoint(0, 180, 250);
        apPC1_ADDi.setPoint(0, 180, 250);

        apID_EX.setPoint(1, 310, 390);

        apRF_A.setPoint(1, 295, 210);
        apRF_A.setPoint(2, 340, 210);
        apMUX5_B.setPoint(1, 340, 240);
        apB_MUX8.setPoint(0, 355, 270);

        //apMUX6_ALU.setPoint(3, 560, 230);
        //apMUX7_ALU.setPoint(3, 560, 230);
				apALU_OUT0.setPoint(3, 520, 240);

        apMUX8_SMDR.setPoint(1, 520, 330);
        apMUX9_OUT1.setPoint(1, 620, 230);

        apID_EX.setHead(1);
        apPC_PC1.setHead(1);
        apRF_A.setHead(1);
        apA_MUX6.setHead(1);
        apMUX5_B.setHead(1);
        apB_MUX8.setHead(1);
        apMUX8_SMDR.setHead(1);
        apMUX6_ALU.setHead(1);
        apMUX7_ALU.setHead(1);
				apALU_OUT0.setHead(1);
        apMUX9_OUT1.setHead(1);

        showBTB(bpMode == BRANCH_PREDICTION ? 1 : 0);
        showALUForwarding(afMode == ALU_FORWARDING ? 1 : 0);
        showSMDRForwarding(sfMode == FORWARDING_TO_SMDR ? 1 : 0);
        showZeroForwarding(zfMode == ZERO_FORWARDING ? 1 : 0);

    }

    apPC_ADD4.setOpacity(opacity);
    cPLUS4.setOpacity(opacity);
    apADD4_MUX1.setOpacity(opacity);

    regPC1.setOpacity(opacity);
    regEX.setOpacity(opacity);
    regMA.setOpacity(opacity);
    regWB.setOpacity(opacity);

    apEX_MA.setOpacity(opacity);
    apMA_WB.setOpacity(opacity);

    regA.setOpacity(opacity);
    regB.setOpacity(opacity);
    regOUT0.setOpacity(opacity);
    regOUT1.setOpacity(opacity);
    regSMDR.setOpacity(opacity);

    buttonBP.label.setOpacity(opacity);
    buttonLI.label.setOpacity(opacity);
    buttonAF.label.setOpacity(opacity);
    buttonSF.label.setOpacity(opacity);
    buttonZF.label.setOpacity(opacity);

}

//
// setPEMode
//
function setPEMode(num mode) {
    peMode = mode;
    if (peMode == 0) {
        buttonPE.setCaption("Pipelining Enabled");
        showPipeline(1);
    } else if (peMode == 1) {
        buttonPE.setCaption("Pipelining Disabled");
        showPipeline(0);
    }
    setArg("peMode", peMode.toString()); // {joj 6/11/16}
}

//
// setBPMode
//
function setBPMode(num mode) {
    bpMode = mode;
    if (bpMode == 0) {
        buttonBP.setCaption("Branch Prediction");
        showBTB(1);
    } else if (bpMode == 1) {
        buttonBP.setCaption("Branch Interlock");
        showBTB(0);
    } else if (bpMode == 2) {
        buttonBP.setCaption("Delayed Branches");
        showBTB(0);
    }
    setArg("bpMode", bpMode.toString()); // {joj 6/11/16}
}

//
// setLIMode
//
function setLIMode(num mode) {
    liMode = mode;
    if (liMode == 0) {
        buttonLI.setCaption("Load Interlock");
    } else if (liMode == 1) {
        buttonLI.setCaption("No Load Interlock");
    }
    setArg("liMode", liMode.toString()); // {joj 6/11/16}
}

//
// setAFMode
//
function setAFMode(num mode) {
    afMode = mode;
    if (afMode == 0) {
        buttonAF.setCaption("ALU Forwarding");
        showALUForwarding(1);
    } else if (afMode == 1) {
        buttonAF.setCaption("ALU Interlock");
        showALUForwarding(0);
    } else if (afMode == 2) {
        buttonAF.setCaption("No ALU Interlock");
        showALUForwarding(0);
    }
    setArg("afMode", afMode.toString()); // {joj 6/11/16}
}

//
// setLIMode
//
function setSFMode(num mode) {
    sfMode = mode;
    if (sfMode == 0) {
        buttonSF.setCaption("Store Operand\nForwarding");
        showSMDRForwarding(1);
    } else if (sfMode == 1) {
        buttonSF.setCaption("Store Interlock");
        showSMDRForwarding(0);
    } else if (sfMode == 2) {
        buttonSF.setCaption("No Store Interlock");
        showSMDRForwarding(0);
    }
    setArg("sfMode", sfMode.toString()); // {joj 6/11/16}
}

//
// setZFMode
//
function setZFMode(num mode) {
    zfMode = mode;
    if (zfMode == 0) {
        buttonZF.setCaption("Zero Forwarding");
        showZeroForwarding(1);
    } else if (zfMode == 1) {
        buttonZF.setCaption("Zero Interlock");
        showZeroForwarding(0);
    } else if (zfMode == 2) {
        buttonZF.setCaption("No Zero Interlock");
        showZeroForwarding(0);
    }
    setArg("zfMode", zfMode.toString()); // {joj 6/11/16}
}

// initialisation

resetCircuit();

num i, v;
string s;

//
// clear instruction memory
//
for (i = 0; i < 32; i++)			// {joj 27/10/06}
    im.setOpcode(4*i, 0);			// {joj 27/10/06}

//
// initialise registers
//
for (i = 0; i < 4; i++) {                           // {joj 31/10/10}
    s = sprintf("r%d", i);							// {joj 2/10/16}
    regFile[i].setValue(getArgAsNum(s, 0));			// {joj 4/10/16}
}                                                   // {joj}

//
// initialise memory
//
for (i = 0; i < 4; i++) {                           // {joj}
    s = sprintf("m%d", i);                          // {joj 31/10/10}
    memory[i].setValue(getArgAsNum(s, 0));			// {joj 7/10/16}
}

setTPS(20);                                         // {joj}
example = getArgAsNum("example", 0);				// {joj 4/10/16}

if (example == 0) {

    //
    // user defined
    //
    for (i = 0; i < 32; i++)  {                     // {joj}
        s = sprintf("i%d", i);						// {joj 31/10/10}
        im.setOpcode(4*i, getArgAsNum(s, 0));       // {joj 20/10/16}
    }

} else if (example == 1) {                          // {joj}

		im.setValue(0, ADDi, 18, 0, 4);
		im.setValue(4, ADDi, 19, 0, 5);
		im.setValue(8, SUBi, 2, 2, 4);
		im.setValue(12, ST, 18, 2, 0);
		im.setValue(16, JAL, 1, 0, 0x14);
		im.setValue(20, XOR, 0, 0, 0);
		im.setValue(0x24, SUB, 20, 19, 18);
		im.setValue(0x28, SUBi, 2, 2, 4);
		im.setValue(0x2C, NOP, 0, 0, 0);
		im.setValue(0x30, JALR, 0, 0, 1);
    im.setValue(44, HALT, 0, 0, 0);                 // {joj}
    regFile[2].setValue(9);                         // {joj}
    regFile[3].setValue(8);                         // {joj}
    //setTPS(100);                                    // {joj}

} else if (example == 2) {                          // {joj}

    //
    // pipeline forwarding example
    //
    im.setValue( 0, ADDi, 2, 0, 4);                   // r1 = r2 + r3     // {joj 20/10/12}


} else if (example == 3) {                          // {joj}

    //
    // tutorial 4
    //
    im.setValue( 0, ADD, 1, 1, 2);					// r1 = r1 + r2     // {joj 13/11/17}
    im.setValue( 4, ADD, 2, 1, 2);					// r2 = r1 + r2		// {joj 13/11/17}
    im.setValue( 8, ADD, 1, 1, 2);					// r1 = r1 + r2		// {joj 13/11/17}
    im.setValue(12, ADD, 2, 1, 2);					// r2 = r1 + r2		// {joj 13/11/17}
    im.setValue(16, ADD, 1, 1, 2);        			// r1 = r1 + r2		// {joj 13/11/17}
    im.setValue(20, HALT, 0, 0, 0);                 // HALT             // {joj 13/11/17}
	regFile[1].setValue(1);                         // r1 = 1           // {joj 13/11/17}
	regFile[2].setValue(2);                         // r2 = 2           // {joj 13/11/17}
	setTPS(50);                                     //

} else if (example == 4) {

	//
    // branch prediction example
    //
    // im.setValue( 0, ADDi, 1, 0, 3);                 //      r1 = 3      // {joj}
    // im.setValue( 4, ADD,  0, 0, 0);                 // L:               // {joj}
    // im.setValue( 8, ADD,  0, 0, 0);                 //                  // {joj}
    // im.setValue(12, SUBi, 1, 1, 1);                 //      r1 = r1-1   // {joj}
    // im.setValue(16, BLT, 0, 1, -12 & 0xff);        //      bnez r1, L  // {joj}
    // im.setValue(20, HALT, 0, 0, 0);                 //                  // {joj}
    // setTPS(50);                                     // {joj}
		im.setValue(0, ADDi, 1, 0, 13);
		im.setValue(4, ADDi, 2, 0, 4);
		im.setValue(8, DIV, 3, 1, 2);

} else if (example == 5) {

	// used to fix reported errors

	// im.setValue( 0,   JR, 0, 0, 1);				// {joj 29/11/16}
	// im.setValue(32,  ADD, 1, 1, 1);				// {joj 29/11/16}
	// im.setValue(36, HALT, 0, 0, 0);				// {joj 29/11/16}
	// regFile[1].setValue(32);					// {joj 29/11/16}
	im.setValue(0, ADDi, 1, 0, 3);
	im.setValue(4, ADDi, 2, 0, 2);
	im.setValue(8, MUL, 3, 1, 2);

	//im.setValue( 0,  ADD, 2, 2, 3);				// {joj 30/11/16}
	//im.setValue( 4,  NOP, 0, 0, 0);				// {joj 30/11/16}
	//im.setValue( 8,  ADD, 1, 2, 3);				// {joj 30/11/16}
	//im.setValue(12, HALT, 0, 0, 0);				// {joj 30/11/16}

	//im.setValue( 0,   LD, 1, 0, 0);					// {joj 5/12/16}
	//im.setValue( 4, BEQZ, 0, 1, 28);				// {joj 5/12/16}
	//im.setValue(32, HALT, 0, 0, 0);					// {joj 5/12/16}

	//im.setValue( 0,   LD, 1, 0, 1);				// {joj 7/12/16}
	//im.setValue( 4,  ADD, 2, 0, 0);				// {joj 7/12/16}
	//im.setValue( 8,  ADD, 3, 0, 0);				// {joj 7/12/16}
	//im.setValue(12, BEQZ, 0, 1, 20);				// {joj 7/12/16}
	//im.setValue(32, HALT, 0, 0, 0);				// {joj 7/12/16}

}


//
// save args
//
if (example > 0) {										// {joj 27/10/06}

    for (i = 0; i < 32; i++) { 							// {joj 27/10/06}
        s = sprintf("i%d", i);							// {joj 31/10/10}
        setArg(s, im.getOpcode(i * 4).toString());		// {joj 6/11/16}
    }

    example = (example > maxexample) ? 0 : example		// {joj 28/11/16}

}

num haltOnHalt = getArgAsNum("haltOnHalt", 1);			// {joj 29/7/08}

bpMode = getArgAsNum("bpMode", 0); setBPMode(bpMode);	// {joj 27/11/16}
liMode = getArgAsNum("liMode", 0); setLIMode(liMode);	// {joj 27/11/16}
afMode = getArgAsNum("afMode", 0); setAFMode(afMode);	// {joj 27/11/16}
sfMode = getArgAsNum("sfMode", 0); setSFMode(sfMode);	// {joj 27/11/16}
zfMode = getArgAsNum("zfMode", 0); setZFMode(zfMode);	// {joj 27/11/16}
peMode = getArgAsNum("peMode", 0); setPEMode(peMode);	// {joj 27/11/16}
lockCircuit = getArgAsNum("locked", 0);					// {joj 27/11/16}

//
// Help
//
// num showHelp = getArgAsNum("help", 1);				// {joj 4/10/16}
//
// Rectangle r = Rectangle2(helpLayer, 0, 0, whiteBrush, 0, 0, WIDTH, HEIGHT);
// r.setOpacity(0.5);                                  // {joj 20/8/10}
// r.setRounded(10, 10);
//
// Pen helpPen = SolidPen(SOLID, 2, RED, ROUND_START | ROUND_JOIN | ROUND_END);
// Font helpFont = Font("Arial", 12, BOLD);
//
// Txt(helpLayer, HLEFT | VTOP, 12, 290, helpPen, helpFont, "LEFT CLICK on animation background to start and stop clock.\n\nSHIFT LEFT CLICK on background to execute \"single MIPS clock cycle\".");
// if (!lockCircuit) {
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 20, 68, 80, 10); r.setRounded(5, 5);
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 25, 121, 30, 10); r.setRounded(5, 5);
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 60, 121, 14, 10); r.setRounded(5, 5);
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 76, 121, 14, 10); r.setRounded(5, 5);
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 92, 121, 14, 10); r.setRounded(5, 5);
//     Txt(helpLayer, HLEFT | VTOP, 110, 60, helpPen, helpFont, "LEFT CLICK to change\ninitial program.");
//     Txt(helpLayer, HLEFT | VTOP, 110, 105, helpPen, helpFont, "LEFT or RIGHT CLICK to \"rotate\"\ninstructions and operands.\nHold and release to reset value.");
// }
//
// r = Rectangle2(helpLayer, 0, helpPen, 0, 310, 25, 90, 50);
// r.setRounded(10, 10);
// Txt(helpLayer, HLEFT | VTOP, 410, 40, helpPen, helpFont, "LEFT or RIGHT CLICK register\nto increment or decrement value.");
//
// if (!lockCircuit) {
//     r = Rectangle2(helpLayer, 0, helpPen, 0, 110, 455, 550, 30);
//     r.setRounded(10, 10);
//     Txt(helpLayer, HLEFT | VTOP, 180, 435, helpPen, helpFont, "LEFT CLICK on any of the buttons below to change circuit configuration.");
// }
//
// Rectangle closeHelp = Rectangle2(helpLayer, 0, helpPen, yellowBrush, 305, 230, 100, 30, helpPen, helpFont, "CLOSE HELP");
// closeHelp.setRounded(5, 5);
//
// when closeHelp ~> eventEE(num enter, num x, num y) {			// {joj 24/9/17}
//     closeHelp.setBrush(enter ? gray224Brush : yellowBrush);		// {joj 17/10/16}
// }
//
// when closeHelp ~> eventMB(num down, num flags, num x, num y) {	// {joj 24/9/17}
// 	if (down && (flags & MB_LEFT)) {
// 		setArg("help", "0");   									// {joj 6/11/16}
// 		helpLayer.setOpacity(0);
// 	}
// 	return 0;
// }
//
// if (showHelp == 0)
//     helpLayer.setOpacity(0);

// eof
